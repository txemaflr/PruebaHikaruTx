
<script>
// scriptsPlanificacion.html - VERSI√ìN LIMPIA
// Variables globales
var mesActual = new Date();
var diaSeleccionado = null;
// Variables del modal
var pasoActual = 1;
var temasSeleccionados = [];
var tiempoTotalDisponible = 240; // minutos
var tiempoUsado = 0;
var bloquesActivos = [];
var configuracionActual = null;
var oposicionActiva = null;
// Variables para sistema de advertencias de dos niveles
let advertenciasOrdenMostradas = {}; // {idTema: numeroDeVeces}
let advertenciasBloquesMostradas = {}; // {combinacionBloques: numeroDeVeces}

/*
// Inicializar secci√≥n de planificaci√≥n
function inicializarSeccionPlanificacion() {
  console.log('üîß Inicializando planificaci√≥n limpia...');
  renderizarCalendario();
  // Auto-seleccionar d√≠a actual
  const hoy = new Date();
  if (mesActual.getMonth() === hoy.getMonth() && mesActual.getFullYear() === hoy.getFullYear()) {
    seleccionarDia(hoy.getDate());
  }
}
*/

// 1. Inicializar secci√≥n de planificaci√≥n
function inicializarSeccionPlanificacion() {
  console.log('Inicializando secci√≥n Planificaci√≥n...');
  cargarOposicionActiva();
  // Al final de inicializarSeccionPlanificacion(), a√±adir:
  setTimeout(() => {
    if (typeof renderizarCalendario === 'function') {
      renderizarCalendario();
    }
  }, 500);
}

// 2. Cargar oposici√≥n activa
function cargarOposicionActiva() {
  google.script.run
    .withSuccessHandler(function(oposicion) {
      oposicionActiva = oposicion;
      console.log('Oposici√≥n activa cargada:', oposicion);
      mostrarPaginaPrincipal();
    })
    .withFailureHandler(function(error) {
      console.error('Error al cargar oposici√≥n activa:', error);
      mostrarPaginaPrincipal();
    })
    .getOposicionActiva();
}

// 3. Mostrar p√°gina principal (VERSI√ìN CON COMPARACI√ìN)
function mostrarPaginaPrincipal() {
  const contenedor = document.getElementById('contenidoPrincipalPlanificacion');
  
  if (!oposicionActiva) {
    // No hay oposici√≥n activa - mostrar selector
    let html = '<div style="text-align: center; padding: 40px;">';
    html += '<h3>Selecciona una oposici√≥n para planificar</h3>';
    html += '<p style="color: #666; margin-bottom: 30px;">Solo puedes tener una oposici√≥n activa a la vez</p>';
    
    html += '<div style="max-width: 400px; margin: 0 auto;">';
    html += '<label style="display: block; margin-bottom: 10px; text-align: left;">Oposici√≥n:</label>';
    html += '<select id="selectorOposicion" style="width: 100%; padding: 10px; margin-bottom: 20px;">';
    html += '<option value="">-- Selecciona una oposici√≥n --</option>';
    html += '</select>';
    
    html += '<button onclick="establecerOposicionActiva()" ';
    html += 'style="background: #007bff; color: white; border: none; padding: 12px 30px; border-radius: 5px; cursor: pointer;">';
    html += 'Establecer como activa</button>';
    html += '</div>';
    html += '</div>';
    
    contenedor.innerHTML = html;
    // A√ëADIR ESTAS L√çNEAS:
    setTimeout(() => {
      inicializarCalendarioPlanificacion();
    }, 200);
    cargarOposicionesDisponibles();
    
  } else {
    // Ya hay oposici√≥n activa
    let html = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">';
    html += '<div>';
    html += '<h3 style="margin: 0; color: #007bff;">üìö ' + oposicionActiva.nombre + '</h3>';
    html += '<p style="margin: 5px 0 0 0; color: #666;">Oposici√≥n activa</p>';
    html += '</div>';
    html += '<div>';
    html += '<button onclick="cambiarOposicion()" style="background: #6c757d; color: white; border: none; padding: 8px 15px; border-radius: 3px; margin-right: 10px;">Cambiar</button>';
    html += '<button id="btnCompararOposiciones" onclick="mostrarComparadorOposiciones()" style="background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 3px; margin-right: 10px;" disabled>';
    html += 'üîç Comparar</button>';
    html += '</div>';
    html += '</div>';
    
    contenedor.innerHTML = html;
    
    // Verificar si hay m√°s de una oposici√≥n para habilitar comparaci√≥n
    verificarOposicionesDisponibles();
  }
}

// 4. Cargar oposiciones disponibles
function cargarOposicionesDisponibles() {
  google.script.run
    .withSuccessHandler(function(oposiciones) {
      const select = document.getElementById('selectorOposicion');
      
      oposiciones.forEach(function(op) {
        const option = document.createElement('option');
        option.value = op.id;
        option.textContent = op.nombre;
        select.appendChild(option);
      });
    })
    .withFailureHandler(function(error) {
      console.error('Error al cargar oposiciones:', error);
      alert('Error al cargar oposiciones');
    })
    .getOposicionesOrdenadas();
}

// 5. Establecer oposici√≥n activa
function establecerOposicionActiva() {
  const idOposicion = document.getElementById('selectorOposicion').value;
  
  if (!idOposicion) {
    alert('Selecciona una oposici√≥n');
    return;
  }
  
  google.script.run
    .withSuccessHandler(function() {
      alert('Oposici√≥n establecida correctamente');
      cargarOposicionActiva();
    })
    .withFailureHandler(function(error) {
      console.error('Error al establecer oposici√≥n activa:', error);
      alert('Error al establecer oposici√≥n activa');
    })
    .setOposicionActiva(idOposicion);
}

// 6. Cambiar oposici√≥n activa (VERSI√ìN CON CANCELAR)
function cambiarOposicion() {
  cambiarOposicionConConfirmacion(); // Usar la funci√≥n con confirmaciones
}

// 7. Verificar si hay m√°s oposiciones para habilitar comparaci√≥n
function verificarOposicionesDisponibles() {
  google.script.run
    .withSuccessHandler(function(oposiciones) {
      const btnComparar = document.getElementById('btnCompararOposiciones');
      if (btnComparar && oposiciones.length > 1) {
        btnComparar.disabled = false;
        btnComparar.title = 'Comparar con otras oposiciones';
      }
    })
    .getOposicionesOrdenadas();
}

// 8. Mostrar comparador de oposiciones (VERSI√ìN COMPLETA)
function mostrarComparadorOposiciones() {
  // Crear modal
  let html = '<div id="modalComparacion" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;">';
  html += '<div style="background: white; padding: 30px; border-radius: 10px; max-width: 800px; width: 90%; max-height: 80%; overflow-y: auto;">';
  
  // Cabecera
  html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">';
  html += '<h4 style="margin: 0;">üîç Comparar Oposiciones</h4>';
  html += '<button onclick="cerrarModalComparacion()" style="background: none; border: none; font-size: 20px; cursor: pointer;">‚úï</button>';
  html += '</div>';
  
  // Informaci√≥n actual
  html += '<div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">';
  html += '<strong>Oposici√≥n activa:</strong> ' + oposicionActiva.nombre;
  html += '</div>';
  
  // Selector de oposici√≥n para comparar
  html += '<div style="margin-bottom: 20px;">';
  html += '<label style="display: block; margin-bottom: 10px;">Comparar con:</label>';
  html += '<select id="selectorOposicionComparar" onchange="cargarComparacion()" style="width: 100%; padding: 10px;">';
  html += '<option value="">-- Selecciona una oposici√≥n --</option>';
  html += '</select>';
  html += '</div>';
  
  // Contenedor de resultados
  html += '<div id="resultadosComparacion"></div>';
  
  html += '</div>';
  html += '</div>';
  
  document.body.insertAdjacentHTML('beforeend', html);
  
  // Cargar oposiciones disponibles para comparar
  cargarOposicionesParaComparar();
}

// 9. Cargar oposiciones para cambio (excluyendo la actual)
function cargarOposicionesParaCambio() {
  google.script.run
    .withSuccessHandler(function(oposiciones) {
      const select = document.getElementById('selectorNuevaOposicion');
      
      oposiciones.forEach(function(op) {
        // Excluir la oposici√≥n actualmente activa
        if (op.id != oposicionActiva.id) {
          const option = document.createElement('option');
          option.value = op.id;
          option.textContent = op.nombre;
          select.appendChild(option);
        }
      });
    })
    .withFailureHandler(function(error) {
      console.error('Error al cargar oposiciones:', error);
      alert('Error al cargar oposiciones');
    })
    .getOposicionesOrdenadas();
}

// 10. Cancelar cambio de oposici√≥n
function cancelarCambioOposicion() {
  // Volver a mostrar la p√°gina principal con la oposici√≥n actual
  mostrarPaginaPrincipal();
}

// 11. Confirmar cambio de oposici√≥n
function confirmarCambioOposicion() {
  const idNuevaOposicion = document.getElementById('selectorNuevaOposicion').value;
  
  if (!idNuevaOposicion) {
    alert('Selecciona una oposici√≥n');
    return;
  }
  
  google.script.run
    .withSuccessHandler(function() {
      alert('Oposici√≥n cambiada correctamente');
      // Recargar la p√°gina principal con la nueva oposici√≥n
      cargarOposicionActiva();
    })
    .withFailureHandler(function(error) {
      console.error('Error al cambiar oposici√≥n:', error);
      alert('Error al cambiar oposici√≥n');
    })
    .setOposicionActiva(idNuevaOposicion);
}

// 12. Cargar oposiciones para comparar (excluyendo la activa)
function cargarOposicionesParaComparar() {
  google.script.run
    .withSuccessHandler(function(oposiciones) {
      const select = document.getElementById('selectorOposicionComparar');
      
      oposiciones.forEach(function(op) {
        if (op.id != oposicionActiva.id) {
          const option = document.createElement('option');
          option.value = op.id;
          option.textContent = op.nombre;
          select.appendChild(option);
        }
      });
    })
    .getOposicionesOrdenadas();
}

// 13. Cargar comparaci√≥n de temas
function cargarComparacion() {
  const idOposicionComparar = document.getElementById('selectorOposicionComparar').value;
  const contenedor = document.getElementById('resultadosComparacion');
  
  if (!idOposicionComparar) {
    contenedor.innerHTML = '';
    return;
  }
  
  contenedor.innerHTML = '<p style="text-align: center;"><i class="fas fa-spinner fa-spin"></i> Cargando comparaci√≥n...</p>';
  
  google.script.run
    .withSuccessHandler(function(temas) {
      mostrarResultadosComparacion(temas, idOposicionComparar);
    })
    .withFailureHandler(function(error) {
      console.error('Error al comparar:', error);
      contenedor.innerHTML = '<p style="color: red; text-align: center;">Error al cargar comparaci√≥n</p>';
    })
    .getTemasComunes(oposicionActiva.id, idOposicionComparar);
}

// 14. Mostrar resultados de la comparaci√≥n (VERSI√ìN √ÅRBOL COLAPSABLE)
function mostrarResultadosComparacion(temas, idOposicionComparar) {
  // Cargar los datos organizados en √°rbol por bloque
  google.script.run
    .withSuccessHandler(function(temasPorBloque) {
      mostrarArbolTemasConCheckboxes(temasPorBloque, idOposicionComparar);
    })
    .withFailureHandler(function(error) {
      console.error('Error al cargar temas en √°rbol:', error);
      const contenedor = document.getElementById('resultadosComparacion');
      contenedor.innerHTML = '<p style="color: red; text-align: center;">Error al cargar temas en √°rbol</p>';
    })
    .getTemassComunesEnArbolPorBloque(oposicionActiva.id, idOposicionComparar);
}

// 16. Mostrar √°rbol de temas con checkboxes (VERSI√ìN NOMBRES CORREGIDOS)
function mostrarArbolTemasConCheckboxes(datosBloquess, idOposicionComparar) {
  const contenedor = document.getElementById('resultadosComparacion');
  
  if (datosBloquess.length === 0) {
    contenedor.innerHTML = '<div style="text-align: center; padding: 20px; background: #fff3cd; border-radius: 5px;">' +
                          '<h5 style="color: #856404;">No hay temas comunes</h5>' +
                          '<p style="color: #856404; margin: 0;">Estas oposiciones no comparten ning√∫n tema.</p>' +
                          '</div>';
    return;
  }
  
  // Calcular estad√≠sticas totales recursivamente
  let stats = calcularEstadisticasRecursivas(datosBloquess);
  
  let html = '<div>';
  
  // Estad√≠sticas generales
  html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px;">';
  html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; text-align: center;">';
  
  html += '<div><strong>' + stats.totalTemas + '</strong><br><span style="color: #666; font-size: 12px;">Temas comunes</span></div>';
  html += '<div><strong style="color: #28a745;">' + stats.totalCompletados + '</strong><br><span style="color: #666; font-size: 12px;">Completados</span></div>';
  html += '<div><strong style="color: #dc3545;">' + stats.totalPendientes + '</strong><br><span style="color: #666; font-size: 12px;">Pendientes</span></div>';
  html += '<div><strong style="color: #007bff;">' + stats.totalHoras.toFixed(1) + 'h</strong><br><span style="color: #666; font-size: 12px;">Tiempo total</span></div>';
  
  html += '</div>';
  html += '</div>';
  
  // Contador de seleccionados
  html += '<div id="contadorSeleccionados" style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px; text-align: center;">';
  html += '<strong>Seleccionados: <span id="temasSeleccionadosCount">0</span> temas | ';
  html += 'Tiempo: <span id="tiempoSeleccionadoCount">0.0</span>h</strong>';
  html += '<button id="btnPlanificarSeleccionados" onclick="planificarTemasSeleccionados()" ';
  html += 'style="background: #28a745; color: white; border: none; padding: 8px 20px; border-radius: 5px; margin-left: 20px;" disabled>';
  html += 'üìÖ Planificar seleccionados</button>';
  html += '</div>';
  
  // Checkbox para seleccionar todos
  html += '<div style="margin-bottom: 15px;">';
  html += '<label style="cursor: pointer; font-weight: bold;">';
  html += '<input type="checkbox" id="seleccionarTodos" onchange="toggleSeleccionarTodos()" style="margin-right: 8px;"> ';
  html += 'Seleccionar todos los temas pendientes';
  html += '</label>';
  html += '</div>';
  
  // Temas por bloque con √°rbol
  datosBloquess.forEach(bloque => {
    html += '<div style="margin-bottom: 20px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">';
    
    // Cabecera del bloque
    html += '<div style="background: #007bff; color: white; padding: 12px; font-weight: bold;">';
    html += 'üìö ' + bloque.nombreBloque + ' (' + (stats.temasPorBloque[bloque.idBloque] || 0) + ' temas comunes)';
    html += '</div>';
    
    // Temas del bloque en formato √°rbol
    html += '<div style="padding: 10px;">';
    html += renderizarArbolTemas(bloque.temas, 0);
    html += '</div>';
    
    html += '</div>';
  });
  
  html += '</div>';
  
  contenedor.innerHTML = html;
}

// 15. Cerrar modal de comparaci√≥n
function cerrarModalComparacion() {
  const modal = document.getElementById('modalComparacion');
  if (modal) {
    modal.remove();
  }
}

// 17. Actualizar contador de temas seleccionados
function actualizarContador() {
  const checkboxes = document.querySelectorAll('.tema-checkbox:checked');
  let totalTemas = checkboxes.length;
  let totalHoras = 0;
  
  checkboxes.forEach(checkbox => {
    totalHoras += parseFloat(checkbox.getAttribute('data-horas'));
  });
  
  document.getElementById('temasSeleccionadosCount').textContent = totalTemas;
  document.getElementById('tiempoSeleccionadoCount').textContent = totalHoras.toFixed(1);
  
  // Habilitar/deshabilitar bot√≥n de planificar
  const btnPlanificar = document.getElementById('btnPlanificarSeleccionados');
  btnPlanificar.disabled = totalTemas === 0;
}

// 18. Toggle seleccionar todos
function toggleSeleccionarTodos() {
  const seleccionarTodos = document.getElementById('seleccionarTodos').checked;
  const checkboxes = document.querySelectorAll('.tema-checkbox');
  
  checkboxes.forEach(checkbox => {
    checkbox.checked = seleccionarTodos;
  });
  
  actualizarContador();
}

// 19. Planificar temas seleccionados (VERSI√ìN CORREGIDA)
function planificarTemasSeleccionados() {
  const checkboxes = document.querySelectorAll('.tema-checkbox:checked');
  
  if (checkboxes.length === 0) {
    alert('Selecciona al menos un tema');
    return;
  }
  
  // Recopilar informaci√≥n completa de temas seleccionados
  const temasSeleccionados = [];
  let tiempoTotal = 0;
  
  checkboxes.forEach(checkbox => {
    const horas = parseFloat(checkbox.getAttribute('data-horas'));
    temasSeleccionados.push({
      id: parseInt(checkbox.getAttribute('data-tema-id')),
      horas: horas
    });
    tiempoTotal += horas;
  });
  
  // Confirmar antes de proceder
  const mensaje = `¬øCrear planificaci√≥n con ${temasSeleccionados.length} temas seleccionados?\n\nTiempo total estimado: ${tiempoTotal.toFixed(1)} horas`;
  
  if (!confirm(mensaje)) {
    return;
  }
  
  // Guardar datos en variable global para usar en nueva planificaci√≥n
  window.temasParaPlanificar = {
    temas: temasSeleccionados,
    tiempoTotal: tiempoTotal,
    origen: 'comparacion'
  };
  
  // Cerrar modal de comparaci√≥n
  cerrarModalComparacion();
  
  // Mostrar modal de nueva planificaci√≥n
  setTimeout(function() {
    mostrarNuevaPlanificacionConTemas();
  }, 100);
}

// 20. Mostrar nueva planificaci√≥n con temas pre-seleccionados (VERSI√ìN COMPLETA)
function mostrarNuevaPlanificacionConTemas() {
  if (!window.temasParaPlanificar) {
    alert('Error: No hay temas seleccionados');
    return;
  }
  
  // Mostrar modal de nueva planificaci√≥n
  document.getElementById('modalNuevaPlanificacion').style.display = 'flex';
  pasoActualPlanificacion = 1;
  fechaSeleccionada = null;
  repasosDiaSeleccionado = [];
  
  // Marcar que viene de comparaci√≥n
  window.modoCreacionPlanificacion = 'desde_comparacion';
  
  // Mostrar paso 1 espec√≠fico para temas de comparaci√≥n
  mostrarPaso1ConTemasPreseleccionados();
}

// 24. Paso 1 espec√≠fico para temas de comparaci√≥n
function mostrarPaso1ConTemasPreseleccionados() {
  const contenedor = document.getElementById('paso1Planificacion') || document.getElementById('paso1');
  
  let html = '<h4>Paso 1: Planificar temas seleccionados</h4>';
  
  // Resumen de temas seleccionados
  html += '<div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">';
  html += '<h5 style="color: #0d47a1; margin: 0 0 10px 0;">üìö Temas de comparaci√≥n seleccionados</h5>';
  html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">';
  html += '<div><strong>' + window.temasParaPlanificar.temas.length + '</strong><br><span style="font-size: 12px;">Temas</span></div>';
  html += '<div><strong>' + window.temasParaPlanificar.tiempoTotal.toFixed(1) + 'h</strong><br><span style="font-size: 12px;">Tiempo estimado</span></div>';
  html += '<div><strong>' + oposicionActiva.nombre + '</strong><br><span style="font-size: 12px;">Oposici√≥n</span></div>';
  html += '</div>';
  html += '</div>';
  
  // Selector de fecha
  html += '<div style="margin-bottom: 20px;">';
  html += '<label style="display: block; margin-bottom: 10px;"><strong>Fecha para planificar:</strong></label>';
  html += '<input type="date" id="fechaPlanificacion" ';
  html += 'min="' + new Date().toISOString().split('T')[0] + '" ';
  html += 'onchange="cargarRepasosDiaConTemas(this.value)" ';
  html += 'style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">';
  html += '</div>';
  
  // Contenedor para repasos del d√≠a
  html += '<div id="repasosDiaContainer" style="margin-bottom: 20px;"></div>';
  
  // Validaciones y advertencias
  html += '<div id="validacionesDia"></div>';
  
  contenedor.innerHTML = html;
  
  // Establecer fecha por defecto (hoy)
  document.getElementById('fechaPlanificacion').value = new Date().toISOString().split('T')[0];
  cargarRepasosDiaConTemas(new Date().toISOString().split('T')[0]);
  
  // Actualizar botones del modal
  const btnAnterior = document.getElementById('btnAnteriorPaso');
  const btnSiguiente = document.getElementById('btnSiguientePaso');

  if (btnAnterior) btnAnterior.style.display = 'none';
  if (btnSiguiente) {
    btnSiguiente.textContent = 'Siguiente: Configurar tiempo';
    btnSiguiente.disabled = false;
  }
}

// 25. Cargar repasos del d√≠a con c√°lculo de tiempo disponible
function cargarRepasosDiaConTemas(fecha) {
  if (!fecha) return;
  
  fechaSeleccionada = new Date(fecha);
  
  const contenedorRepasos = document.getElementById('repasosDiaContainer');
  const contenedorValidaciones = document.getElementById('validacionesDia');
  
  contenedorRepasos.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Verificando d√≠a y repasos...</p>';
  
  // Verificar si el d√≠a es modificable
  google.script.run
    .withSuccessHandler(function(esModificable) {
      if (!esModificable) {
        mostrarDiaNoModificableConTemas(fecha);
        return;
      }
      
      // Cargar repasos del d√≠a
      google.script.run
        .withSuccessHandler(function(repasos) {
          repasosDiaSeleccionado = repasos;
          mostrarRepasosDiaConTemas(repasos);
          validarDisponibilidadDiaConTemas(repasos);
        })
        .withFailureHandler(function(error) {
          console.error('Error al cargar repasos:', error);
          contenedorRepasos.innerHTML = '<p style="color: red;">Error al cargar repasos</p>';
        })
        .getRepasosDelDia(fechaMs); // Usar el nombre correcto
    })
    .withFailureHandler(function(error) {
      console.error('Error al verificar d√≠a:', error);
    })
    .esDiaModificable(fecha);
}




// 21. Calcular estad√≠sticas recursivamente (VERSI√ìN CORREGIDA)
function calcularEstadisticasRecursivas(bloquesDatos) {
  let totalTemas = 0;
  let totalCompletados = 0;
  let totalHoras = 0;
  let contadorPorBloque = {};
  
  function contarTemaRecursivo(tema) {
    if (tema.esComun) {
      totalTemas++;
      if (tema.completado) totalCompletados++;
      totalHoras += tema.horasEstimadas || 0;
      
      const idBloque = tema.id_bloque || 'sin_bloque';
      contadorPorBloque[idBloque] = (contadorPorBloque[idBloque] || 0) + 1;
    }
    
    if (tema.hijos) {
      tema.hijos.forEach(hijo => contarTemaRecursivo(hijo));
    }
  }
  
  bloquesDatos.forEach(bloque => {
    bloque.temas.forEach(tema => contarTemaRecursivo(tema));
  });
  
  return {
    totalTemas: totalTemas,
    totalCompletados: totalCompletados,
    totalPendientes: totalTemas - totalCompletados,
    totalHoras: totalHoras,
    temasPorBloque: contadorPorBloque
  };
}

// 22. Renderizar √°rbol de temas de forma recursiva
function renderizarArbolTemas(temas, nivel) {
  let html = '';
  const margenIzquierdo = nivel * 20;
  
  temas.forEach(tema => {
    // Solo mostrar si es com√∫n (tiene checkbox) o tiene hijos comunes
    const tieneHijosComunes = tema.hijos && tema.hijos.some(hijo => hijo.esComun || (hijo.hijos && hijo.hijos.length > 0));
    
    if (tema.esComun || tieneHijosComunes) {
      const estado = tema.completado ? '‚úÖ' : '‚≠ï';
      const colorFondo = tema.completado ? '#d4edda' : '#f8f9fa';
      
      html += '<div style="margin-left: ' + margenIzquierdo + 'px; margin-bottom: 5px;">';
      html += '<div style="display: flex; align-items: center; padding: 8px; background: ' + colorFondo + '; border-radius: 5px;">';
      
      // Icono de colapsar/expandir si tiene hijos
      if (tema.hijos && tema.hijos.length > 0) {
        html += '<span onclick="toggleArbol(this)" style="cursor: pointer; margin-right: 8px; user-select: none; width: 16px; text-align: center;">‚ñº</span>';
      } else {
        html += '<span style="margin-right: 8px; width: 16px;"></span>';
      }
      
      // Checkbox solo para temas comunes y pendientes
      if (tema.esComun && !tema.completado) {
        html += '<input type="checkbox" class="tema-checkbox" ';
        html += 'data-tema-id="' + tema.id + '" ';
        html += 'data-horas="' + (tema.horasEstimadas || 0) + '" ';
        html += 'onchange="actualizarContador()" ';
        html += 'style="margin-right: 10px;">';
      } else if (tema.esComun && tema.completado) {
        html += '<span style="margin-right: 10px; width: 16px; text-align: center;">‚úÖ</span>';
      } else {
        html += '<span style="margin-right: 10px; width: 16px;"></span>';
      }
      
      // Informaci√≥n del tema
      html += '<div style="flex: 1;">';
      html += '<strong>' + tema.nombreCompleto + '</strong>';
      
      if (tema.esComun) {
        html += '<br><small style="color: #666;">';
        html += (tema.paginas || 0) + ' p√°ginas | ' + (tema.horasEstimadas || 0).toFixed(1) + 'h estimadas';
        if (tema.completado) {
          html += ' | <span style="color: #28a745;">Completado</span>';
        }
        html += '</small>';
      }
      html += '</div>';
      
      html += '</div>';
      
      // Renderizar hijos (inicialmente visibles)
      if (tema.hijos && tema.hijos.length > 0) {
        html += '<div class="hijos-tema">';
        html += renderizarArbolTemas(tema.hijos, nivel + 1);
        html += '</div>';
      }
      
      html += '</div>';
    }
  });
  
  return html;
}

// 23. Toggle √°rbol (colapsar/expandir)
function toggleArbol(elemento) {
  const contenedorHijos = elemento.parentElement.parentElement.querySelector('.hijos-tema');
  if (contenedorHijos) {
    if (contenedorHijos.style.display === 'none') {
      contenedorHijos.style.display = 'block';
      elemento.textContent = '‚ñº';
    } else {
      contenedorHijos.style.display = 'none';
      elemento.textContent = '‚ñ∂';
    }
  }
}

// 26. Mostrar d√≠a no modificable para temas de comparaci√≥n
function mostrarDiaNoModificableConTemas(fecha) {
  const contenedorRepasos = document.getElementById('repasosDiaContainer');
  const contenedorValidaciones = document.getElementById('validacionesDia');
  
  contenedorRepasos.innerHTML = '';
  
  let html = '<div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin-bottom: 15px;">';
  html += '<h5 style="color: #856404; margin: 0 0 10px 0;"><i class="fas fa-exclamation-triangle"></i> D√≠a no modificable</h5>';
  html += '<p style="margin: 0; color: #856404;">Los d√≠as anteriores no se pueden modificar. Selecciona hoy o una fecha futura.</p>';
  html += '</div>';
  
  contenedorValidaciones.innerHTML = html;
  document.getElementById('btnSiguientePaso').disabled = true;
}

// 27. Mostrar repasos del d√≠a para temas de comparaci√≥n
function mostrarRepasosDiaConTemas(repasos) {
  const contenedor = document.getElementById('repasosDiaContainer');
  
  if (repasos.length === 0) {
    contenedor.innerHTML = '<div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 5px;">' +
                          '<h5 style="color: #155724; margin: 0 0 5px 0;"><i class="fas fa-check-circle"></i> Sin repasos programados</h5>' +
                          '<p style="margin: 0; color: #155724;">Perfecto, todo el tiempo estar√° disponible para los temas seleccionados.</p>' +
                          '</div>';
    return;
  }
  
  let tiempoTotalRepasos = repasos.reduce((total, repaso) => total + repaso.tiempoEstimado, 0);
  
  let html = '<div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px;">';
  html += '<h5 style="color: #856404; margin: 0 0 10px 0;"><i class="fas fa-redo"></i> Repasos programados (' + repasos.length + ')</h5>';
  html += '<p style="color: #856404; margin: 0 0 10px 0;">Estos repasos reducir√°n el tiempo disponible para estudiar.</p>';
  
  repasos.forEach(function(repaso) {
    html += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #ffeaa7;">';
    html += '<div><strong>R' + repaso.numeroRepaso + ':</strong> ' + repaso.nombreTema + '</div>';
    html += '<div style="color: #856404; font-size: 12px;">' + repaso.tiempoEstimado + ' min</div>';
    html += '</div>';
  });
  
  html += '<div style="text-align: right; margin-top: 10px; font-weight: bold; color: #856404;">';
  html += 'Tiempo total repasos: ' + Math.round(tiempoTotalRepasos / 60 * 10) / 10 + ' horas';
  html += '</div>';
  html += '</div>';
  
  contenedor.innerHTML = html;
}

// 28. Validar disponibilidad con c√°lculo de tiempo
function validarDisponibilidadDiaConTemas(repasos) {
  const contenedor = document.getElementById('validacionesDia');
  
  const tiempoRepasos = repasos.reduce((total, repaso) => total + repaso.tiempoEstimado, 0) / 60; // en horas
  const tiempoTemas = window.temasParaPlanificar.tiempoTotal;
  const tiempoMinimoNecesario = tiempoRepasos + tiempoTemas;
  
  let html = '<div style="background: #e3f2fd; border: 1px solid #bbdefb; padding: 15px; border-radius: 5px;">';
  html += '<h5 style="color: #0d47a1; margin: 0 0 10px 0;">‚è±Ô∏è C√°lculo de tiempo</h5>';
  html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center; margin-bottom: 10px;">';
  
  html += '<div style="padding: 8px; background: #fff3e0; border-radius: 3px;">';
  html += '<div style="font-weight: bold;">' + tiempoRepasos.toFixed(1) + 'h</div>';
  html += '<div style="font-size: 12px;">Repasos</div>';
  html += '</div>';
  
  html += '<div style="padding: 8px; background: #e8f5e8; border-radius: 3px;">';
  html += '<div style="font-weight: bold;">' + tiempoTemas.toFixed(1) + 'h</div>';
  html += '<div style="font-size: 12px;">Temas nuevos</div>';
  html += '</div>';
  
  html += '<div style="padding: 8px; background: #f3e5f5; border-radius: 3px;">';
  html += '<div style="font-weight: bold;">' + tiempoMinimoNecesario.toFixed(1) + 'h</div>';
  html += '<div style="font-size: 12px;">Total necesario</div>';
  html += '</div>';
  
  html += '</div>';
  html += '<p style="margin: 0; color: #0d47a1; text-align: center;"><strong>En el siguiente paso podr√°s ajustar las horas de estudio disponibles.</strong></p>';
  html += '</div>';
  
  contenedor.innerHTML = html;
  document.getElementById('btnSiguientePaso').disabled = false;
}

// 29. Funci√≥n para mostrar paso 1 normal (no desde comparaci√≥n)
// CORRECCI√ìN 2: En scriptsPlanificacion.html
// Reemplazar la funci√≥n mostrarPaso1Normal() existente

function mostrarPaso1Normal() {
  const contenedor = document.getElementById('paso1');
  
  if (!oposicionActiva) {
    contenedor.innerHTML = '<div style="text-align: center; padding: 20px; color: red;">' +
                          '<h5>‚ö†Ô∏è Error: No hay oposici√≥n activa</h5>' +
                          '<p>Debes tener una oposici√≥n activa para crear planificaciones.</p>' +
                          '</div>';
    document.getElementById('btnSiguiente').disabled = true;
    return;
  }
  
  let html = '<h4>Paso 1: Configurar d√≠a de planificaci√≥n</h4>';
  
  // Informaci√≥n de oposici√≥n activa (no editable)
  html += '<div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">';
  html += '<h5 style="color: #0d47a1; margin: 0 0 5px 0;">üìö Oposici√≥n activa</h5>';
  html += '<p style="margin: 0; font-weight: bold; color: #0d47a1;">' + oposicionActiva.nombre + '</p>';
  html += '</div>';
  
  // Selector de fecha
  html += '<div style="margin-bottom: 20px;">';
  html += '<label style="display: block; margin-bottom: 10px; font-weight: bold;">Fecha para planificar:</label>';
  html += '<input type="date" id="fechaPlanificacion" ';
  html += 'min="' + new Date().toISOString().split('T')[0] + '" ';
  html += 'onchange="verificarRepasosDelDia()" ';
  html += 'style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">';
  html += '</div>';
  
  // ‚úÖ CORRECCI√ìN: Contenedor para repasos del d√≠a con ID correcto
  html += '<div id="alertaRepasos" style="display: none; background: #fff3cd; border: 1px solid #ffc107; border-radius: 5px; padding: 15px; margin-bottom: 20px;">';
  html += '<h6 style="margin: 0 0 10px 0; color: #856404;">‚ö†Ô∏è Repasos programados para este d√≠a:</h6>';
  html += '<div id="listaRepasos"></div>';
  html += '<p style="margin: 10px 0 0 0; font-size: 14px; color: #856404;">';
  html += '<strong>Nota:</strong> Estos repasos reducir√°n el tiempo disponible para temas nuevos.';
  html += '</p>';
  html += '</div>';
  
  contenedor.innerHTML = html;
  
  console.log('‚úÖ Paso 1 normal renderizado con IDs correctos');
}

// 30. Funci√≥n principal que decide qu√© mostrar en paso 1
function mostrarPaso1() {
  if (window.modoCreacionPlanificacion === 'desde_comparacion' && window.temasParaPlanificar) {
    mostrarPaso1ConTemasPreseleccionados();
  } else {
    mostrarPaso1Normal();
  }
}

// 31. Funci√≥n actualizada para calcular tiempo correctamente
// CORRECCI√ìN 5: En scriptsPlanificacion.html
// Reemplazar la funci√≥n actualizarCalculoTiempo() existente

function actualizarCalculoTiempo() {
  console.log('‚è±Ô∏è Actualizando c√°lculo de tiempo...');
  
  // Obtener horas previstas del input
  const horasInput = document.getElementById('horasEstudio');
  const horasPrevistas = parseFloat(horasInput ? horasInput.value : 4) || 4;
  const minutosPrevistas = horasPrevistas * 60;
  
  console.log('üìù Horas previstas:', horasPrevistas, 'h =', minutosPrevistas, 'min');
  
  // Calcular tiempo de repasos (30 min por repaso)
  const repasos = window.repasosDelDia || [];
  const tiempoRepasos = repasos.length * 30; // 30 min por repaso
  
  console.log('üìö Repasos encontrados:', repasos.length, '=', tiempoRepasos, 'min');
  
  // C√ÅLCULO CORRECTO: Tiempo real = Tiempo previsto - Tiempo de repasos
  const tiempoRealEstudio = Math.max(0, minutosPrevistas - tiempoRepasos);
  
  console.log('‚úÖ C√ÅLCULO FINAL:');
  console.log('   - Tiempo previsto:', minutosPrevistas, 'min');
  console.log('   - Tiempo repasos:', tiempoRepasos, 'min');
  console.log('   - Tiempo real para temas:', tiempoRealEstudio, 'min');
  
  // Actualizar variables globales
  tiempoTotalDisponible = tiempoRealEstudio; // ‚Üê SOLO el tiempo real para temas nuevos
  window.tiempoTotalParaPlanificacion = minutosPrevistas; // ‚Üê Tiempo total previsto
  window.tiempoRepasosDelDia = tiempoRepasos; // ‚Üê Tiempo de repasos
  window.tiempoRealParaTemas = tiempoRealEstudio; // ‚Üê Tiempo real para temas
  
  // Actualizar interfaz (verificar que existen los elementos)
  const elementoEstudio = document.getElementById('tiempoEstudio');
  const elementoRepasos = document.getElementById('tiempoRepasos');
  const elementoTotal = document.getElementById('tiempoTotalConRepasos');
  
  if (elementoEstudio) elementoEstudio.textContent = tiempoRealEstudio + ' min';
  if (elementoRepasos) elementoRepasos.textContent = tiempoRepasos + ' min';
  if (elementoTotal) elementoTotal.textContent = minutosPrevistas + ' min';
  
  // Mostrar advertencia si el tiempo es muy bajo
  mostrarAdvertenciaTiempo(tiempoRealEstudio, tiempoRepasos, minutosPrevistas);
  
  console.log('üîß Variables globales actualizadas:');
  console.log('   - tiempoTotalDisponible:', tiempoTotalDisponible);
  console.log('   - window.tiempoRealParaTemas:', window.tiempoRealParaTemas);
}

// 32. Mostrar advertencia si el tiempo es insuficiente
function mostrarAdvertenciaTiempo(tiempoReal, tiempoRepasos, tiempoTotal) {
  let advertenciaDiv = document.getElementById('advertenciaTiempo');
  
  // Crear div de advertencia si no existe
  if (!advertenciaDiv) {
    advertenciaDiv = document.createElement('div');
    advertenciaDiv.id = 'advertenciaTiempo';
    advertenciaDiv.style.marginTop = '15px';
    document.getElementById('infoConfiguracion').parentElement.appendChild(advertenciaDiv);
  }
  
  if (tiempoReal <= 30) { // Menos de 30 minutos para estudiar
    let html = '<div style="background: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px;">';
    html += '<h6 style="color: #721c24; margin: 0 0 10px 0;">‚ö†Ô∏è Advertencia de tiempo</h6>';
    
    if (tiempoReal <= 0) {
      html += '<p style="margin: 0; color: #721c24;">Los repasos ocupan todo el tiempo disponible o m√°s. ';
      html += 'Considera aumentar las horas previstas o posponer algunos repasos.</p>';
    } else {
      html += '<p style="margin: 0; color: #721c24;">Solo quedan ' + tiempoReal + ' minutos para temas nuevos despu√©s de los repasos. ';
      html += 'Podr√°s seleccionar muy pocos temas.</p>';
    }
    html += '</div>';
    
    advertenciaDiv.innerHTML = html;
  } else {
    advertenciaDiv.innerHTML = ''; // Limpiar advertencia
  }
}

// 33. Validaci√≥n del paso 2 (actualizada)
// CORRECCI√ìN 9: En scriptsPlanificacion.html
// Reemplazar la funci√≥n validarPaso2() existente

function validarPaso2() {
  console.log('‚úÖ Validando paso 2...');
  
  const horasInput = document.getElementById('horasEstudio');
  const horas = parseFloat(horasInput ? horasInput.value : 0);
  
  console.log('üìä Horas ingresadas:', horas);
  console.log('üìä Tiempo real para temas:', window.tiempoRealParaTemas);
  console.log('üìä Tiempo de repasos:', window.tiempoRepasosDelDia);
  
  // Validaci√≥n b√°sica de horas
  if (!horas || horas < 0.5) {
    alert('‚ö†Ô∏è Introduce un tiempo de estudio v√°lido (m√≠nimo 0.5 horas)');
    if (horasInput) horasInput.focus();
    return false;
  }
  
  if (horas > 12) {
    const confirmar = confirm('‚ö†Ô∏è Has introducido ' + horas + ' horas de estudio.\n\n' +
                            '¬øEst√°s seguro? Es mucho tiempo para un d√≠a.');
    if (!confirmar) {
      if (horasInput) horasInput.focus();
      return false;
    }
  }
  
  // Validaci√≥n de tiempo disponible
  const tiempoReal = window.tiempoRealParaTemas || 0;
  const tiempoRepasos = window.tiempoRepasosDelDia || 0;
  
  if (tiempoReal <= 0) {
    const mensaje = '‚ö†Ô∏è Los repasos (' + Math.round(tiempoRepasos / 60 * 10) / 10 + 'h) ocupan todo el tiempo disponible o m√°s.\n\n' +
                   '¬øQuieres continuar? Solo podr√°s gestionar los repasos, no a√±adir temas nuevos.';
    
    const confirmar = confirm(mensaje);
    if (!confirmar) {
      if (horasInput) horasInput.focus();
      return false;
    }
    
    console.log('‚ö†Ô∏è Usuario confirm√≥ continuar sin tiempo para temas nuevos');
  }
  
  if (tiempoReal > 0 && tiempoReal < 60) { // Menos de 1 hora
    const mensaje = '‚ö†Ô∏è Solo tienes ' + tiempoReal + ' minutos (' + Math.round(tiempoReal / 60 * 10) / 10 + 'h) para temas nuevos.\n\n' +
                   '¬øQuieres continuar con tan poco tiempo?';
    
    const confirmar = confirm(mensaje);
    if (!confirmar) {
      if (horasInput) horasInput.focus();
      return false;
    }
  }
  
  console.log('‚úÖ Paso 2 validado correctamente');
  return true;
}

// 34. Pre-cargar temas seleccionados de la comparaci√≥n
function precargarTemasDeComparacion() {
  // Limpiar selecci√≥n anterior
  temasSeleccionados = [];
  bloquesActivos = [];
  tiempoUsado = 0;
  
  console.log('üîÑ Pre-cargando temas de comparaci√≥n:', window.temasParaPlanificar.temas);
  
  // Convertir temas de comparaci√≥n al formato esperado
  window.temasParaPlanificar.temas.forEach(tema => {
    const tiempoMinutos = Math.round(tema.horas * 60); // Convertir horas a minutos
    
    temasSeleccionados.push({
      id: tema.id,
      tiempo: tiempoMinutos,
      bloque: 'pre-seleccionado', // Se actualizar√° al cargar el √°rbol
      tipo: 'comparacion'
    });
    
    tiempoUsado += tiempoMinutos;
  });
  
  console.log('‚úÖ Temas pre-cargados:', temasSeleccionados.length);
  console.log('‚è±Ô∏è Tiempo pre-usado:', tiempoUsado, 'min');
}

// 35. Cargar √°rbol de temas corregido (SIN ERROR)
function cargarArbolTemasCorregido() {
  const idOposicion = oposicionActiva ? oposicionActiva.id : null;
  const contenedor = document.getElementById('arbolTemas');
  
  if (!idOposicion) {
    contenedor.innerHTML = '<p style="color: red; text-align: center;">Error: No hay oposici√≥n activa</p>';
    return;
  }
  
  // VARIABLE CORREGIDA: usar tiempoTotalDisponible en lugar de tiempoEstudioDisponible
  const tiempoDisponibleReal = tiempoTotalDisponible;
  
  console.log('üå≥ Cargando √°rbol para oposici√≥n:', idOposicion);
  console.log('‚è±Ô∏è Tiempo disponible real:', tiempoDisponibleReal, 'min');
  
  // Mostrar loading
  contenedor.innerHTML = '<p style="text-align: center; color: #666;"><i class="fas fa-spinner fa-spin"></i> Cargando √°rbol de temas...</p>';
  
  google.script.run
    .withSuccessHandler(function(data) {
      console.log('‚úÖ √Årbol de temas recibido:', data);
      
      // Guardar √°rbol global para validaciones
      window.arbolCompletoGlobal = data.arbol;
      
      if (!data || !data.arbol || data.arbol.length === 0) {
        contenedor.innerHTML = '<p style="text-align: center; color: #999;">No hay temas principales vinculados a esta oposici√≥n</p>';
        return;
      }
      
      // Renderizar √°rbol con temas pre-seleccionados
      renderizarArbolConTemasPreseleccionados(data.arbol, data.minutosPorPagina, data.bloques);
      
      // Actualizar informaci√≥n de bloques para temas pre-seleccionados
      actualizarBloquesTemasPreseleccionados(data.arbol);
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al cargar √°rbol:', error);
      contenedor.innerHTML = '<p style="color: red; text-align: center;">Error al cargar temas: ' + error.message + '</p>';
    })
    .getArbolTemasConEstados(idOposicion, tiempoDisponibleReal); // VARIABLE CORREGIDA
}

// 36. Renderizar nodo con verificaci√≥n de pre-selecci√≥n
// CORRECCI√ìN 40: En scriptsPlanificacion.html
// Reemplazar la funci√≥n renderizarNodoTemaConPreseleccion() existente

function renderizarNodoTemaConPreseleccion(nodo, nivel, nombreBloque) {
  const margenIzquierdo = nivel * 20;
  const iconoEstado = getIconoEstado(nodo.estado);
  const colorFondo = getColorFondo(nodo.estado);
  
  // Verificar si est√° pre-seleccionado
  const estaPreseleccionado = temasSeleccionados.some(t => t.id === nodo.id);
  const tieneHijos = nodo.hijos && nodo.hijos.length > 0;
  
  let html = '';
  
  // Contenedor del nodo
  html += '<div style="margin-left: ' + margenIzquierdo + 'px; margin-bottom: 8px;">';
  
  // Fila principal del tema
  html += '<div style="display: flex; align-items: center; padding: 10px; background: ' + colorFondo + '; border: 1px solid #e0e0e0; border-radius: 6px;">';
  
  // NUEVA L√ìGICA DE VISUALIZACI√ìN:
  if (tieneHijos) {
    // TEMA CON HIJOS: Icono de colapsar/expandir + info + (opcionalmente checkbox si es seleccionable como padre)
    
    // Icono de colapsar/expandir
    html += '<span onclick="toggleColapsarTema(this, \'' + nodo.id + '\')" ';
    html += 'style="cursor: pointer; margin-right: 8px; user-select: none; width: 16px; text-align: center; font-weight: bold; color: #007bff;">‚ñ∂</span>';
    
    // Checkbox para tema padre (si es seleccionable como padre)
    if (nodo.seleccionablePadre) {
      html += '<input type="checkbox" ';
      html += 'onchange="toggleSeleccionTemaConValidacion(this, ' + nodo.id + ', ' + nodo.tiempoMinutos + ', \'' + nombreBloque + '\', \'padre\')" ';
      html += (estaPreseleccionado ? 'checked ' : '');
      html += 'style="margin-right: 10px; transform: scale(1.2);" ';
      html += 'title="Seleccionar tema completo (' + nodo.tiempoTexto + ')">';
      
      if (estaPreseleccionado) {
        html += '<span style="margin-left: 5px; background: #007bff; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">PRE-SEL</span>';
      }
    } else {
      // Solo icono de estado para temas padre no seleccionables
      html += '<span style="width: 24px; margin-right: 10px; text-align: center; font-size: 16px;">' + iconoEstado + '</span>';
    }
    
  } else {
    // TEMA HOJA (SIN HIJOS): Checkbox directo
    
    html += '<span style="width: 16px; margin-right: 8px;"></span>'; // Espacio para alineaci√≥n
    
    if (nodo.seleccionable) {
      html += '<input type="checkbox" ';
      html += 'onchange="toggleSeleccionTemaConValidacion(this, ' + nodo.id + ', ' + nodo.tiempoMinutos + ', \'' + nombreBloque + '\', \'hijo\')" ';
      html += (estaPreseleccionado ? 'checked ' : '');
      html += 'style="margin-right: 10px; transform: scale(1.2);" ';
      html += 'title="Seleccionar subtema (' + nodo.tiempoTexto + ')">';
      
      if (estaPreseleccionado) {
        html += '<span style="margin-left: 5px; background: #007bff; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">PRE-SEL</span>';
      }
    } else {
      html += '<span style="width: 24px; margin-right: 10px; text-align: center; font-size: 16px;">' + iconoEstado + '</span>';
    }
  }
  
  // Contenido del tema (nombre e informaci√≥n)
  html += '<div style="flex: 1;">';
  html += '<div style="font-weight: ' + (nivel === 0 ? 'bold' : 'normal') + '; color: ' + getColorTexto(nodo.estado) + ';">';
  html += nodo.nombreCompleto;
  
  // Mostrar info de hijos si los tiene
  if (tieneHijos) {
    const hijosCount = contarHijosRecursivo(nodo);
    html += ' <span style="color: #666; font-size: 12px;">(' + hijosCount + ' subtemas)</span>';
  }
  
  html += '</div>';
  
  if (nodo.paginas > 0) {
    html += '<small style="color: #666; font-size: 11px;">';
    html += nodo.paginas + ' p√°gs ‚Ä¢ ' + nodo.tiempoTexto;
    html += '</small>';
  }
  html += '</div>';
  
  // Badge de estado
  html += '<div style="margin-left: 10px;">';
  html += '<span style="font-size: 10px; padding: 3px 8px; border-radius: 12px; background: ' + getColorBadge(nodo.estado) + '; color: white; font-weight: bold;">';
  html += getTextoEstado(nodo.estado);
  html += '</span>';
  html += '</div>';
  
  html += '</div>'; // Fin de fila principal
  
  // Contenedor de hijos (inicialmente oculto si tiene hijos)
  if (tieneHijos) {
    html += '<div id="hijos-' + nodo.id + '" style="display: none; margin-top: 5px;">';
    
    // Renderizar hijos recursivamente
    nodo.hijos.forEach(hijo => {
      html += renderizarNodoTemaConPreseleccion(hijo, nivel + 1, nombreBloque);
    });
    
    html += '</div>'; // Fin de contenedor de hijos
  }
  
  html += '</div>'; // Fin de contenedor del nodo
  
  return html;
}

// Nueva funci√≥n para colapsar/expandir temas
function toggleColapsarTema(elemento, idTema) {
  const contenedorHijos = document.getElementById('hijos-' + idTema);
  
  if (contenedorHijos) {
    if (contenedorHijos.style.display === 'none') {
      // Expandir
      contenedorHijos.style.display = 'block';
      elemento.textContent = '‚ñº';
      elemento.style.color = '#28a745';
      console.log('üìÇ Tema expandido:', idTema);
    } else {
      // Colapsar
      contenedorHijos.style.display = 'none';
      elemento.textContent = '‚ñ∂';
      elemento.style.color = '#007bff';
      console.log('üìÅ Tema colapsado:', idTema);
    }
  }
}

// Funci√≥n auxiliar para contar hijos recursivamente
function contarHijosRecursivo(nodo) {
  if (!nodo.hijos || nodo.hijos.length === 0) {
    return 0;
  }
  
  let total = nodo.hijos.length;
  nodo.hijos.forEach(hijo => {
    total += contarHijosRecursivo(hijo);
  });
  
  return total;
}

// Nueva funci√≥n para expandir autom√°ticamente temas con selecciones
function expandirTemasConSelecciones() {
  console.log('üîÑ Expandiendo autom√°ticamente temas con selecciones...');
  
  temasSeleccionados.forEach(tema => {
    // Expandir el camino hacia este tema
    expandirCaminoHaciaTema(tema.id);
  });
}

// Funci√≥n para expandir el camino hacia un tema espec√≠fico
function expandirCaminoHaciaTema(idTema) {
  const nodo = encontrarNodoEnArbolCompleto(idTema, window.arbolCompletoGlobal);
  if (!nodo) return;
  
  // Obtener todos los ancestros del tema
  const ancestros = [];
  let nodoActual = nodo;
  
  while (nodoActual) {
    const padre = obtenerTemaPadreReal(nodoActual, window.arbolCompletoGlobal);
    if (padre) {
      ancestros.unshift(padre); // A√±adir al inicio para mantener orden jer√°rquico
      nodoActual = padre;
    } else {
      break;
    }
  }
  
  // Expandir todos los ancestros
  ancestros.forEach(ancestro => {
    const contenedorHijos = document.getElementById('hijos-' + ancestro.id);
    const iconoExpandir = document.querySelector('[onclick="toggleColapsarTema(this, \'' + ancestro.id + '\')"]');
    
    if (contenedorHijos && contenedorHijos.style.display === 'none') {
      contenedorHijos.style.display = 'block';
      if (iconoExpandir) {
        iconoExpandir.textContent = '‚ñº';
        iconoExpandir.style.color = '#28a745';
      }
      console.log('üìÇ Auto-expandido ancestro:', ancestro.nombreCompleto);
    }
  });
}

// 37. Actualizar informaci√≥n de bloques para temas pre-seleccionados
function actualizarBloquesTemasPreseleccionados(arbolTemas) {
  // Funci√≥n recursiva para buscar tema en √°rbol
  function buscarTemaEnArbol(arbol, idBuscado) {
    for (let tema of arbol) {
      if (tema.id === idBuscado) {
        return tema;
      }
      if (tema.hijos && tema.hijos.length > 0) {
        const encontrado = buscarTemaEnArbol(tema.hijos, idBuscado);
        if (encontrado) return encontrado;
      }
    }
    return null;
  }
  
  // Actualizar informaci√≥n de bloque para cada tema pre-seleccionado
  temasSeleccionados.forEach((tema, index) => {
    if (tema.tipo === 'comparacion') {
      const nodoCompleto = buscarTemaEnArbol(arbolTemas, tema.id);
      if (nodoCompleto) {
        // Obtener nombre del bloque del nodo
        const nombreBloque = obtenerNombreBloqueDeNodo(nodoCompleto, arbolTemas);
        temasSeleccionados[index].bloque = nombreBloque;
        
        // A√±adir bloque a activos si no est√°
        if (!bloquesActivos.includes(nombreBloque)) {
          bloquesActivos.push(nombreBloque);
        }
      }
    }
  });
  
  console.log('üîÑ Bloques activos actualizados:', bloquesActivos);
  console.log('üîÑ Temas con bloques actualizados:', temasSeleccionados);
}

// 38. Funci√≥n mejorada para cambiar oposici√≥n con confirmaciones
function cambiarOposicionConConfirmacion() {
  // Verificar si la oposici√≥n actual tiene progreso
  google.script.run
    .withSuccessHandler(function(progreso) {
      if (progreso.tieneProgreso) {
        mostrarDialogoConfirmacionCambio(progreso);
      } else {
        // No tiene progreso, cambiar directamente
        mostrarSelectorNuevaOposicion();
      }
    })
    .withFailureHandler(function(error) {
      console.error('Error al verificar progreso:', error);
      // En caso de error, continuar con el cambio
      mostrarSelectorNuevaOposicion();
    })
    .verificarProgresoOposicion(oposicionActiva.id);
}

// 39. Mostrar di√°logo de confirmaci√≥n cuando hay progreso
function mostrarDialogoConfirmacionCambio(progreso) {
  const contenedor = document.getElementById('contenidoPrincipalPlanificacion');
  
  let html = '<div style="text-align: center; padding: 40px;">';
  html += '<div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 30px; border-radius: 10px; max-width: 600px; margin: 0 auto;">';
  
  html += '<h3 style="color: #856404; margin: 0 0 20px 0;">‚ö†Ô∏è Cambiar oposici√≥n con progreso</h3>';
  
  html += '<p style="color: #856404; margin-bottom: 20px;">La oposici√≥n actual <strong>' + oposicionActiva.nombre + '</strong> tiene progreso:</p>';
  
  // Mostrar estad√≠sticas de progreso
  html += '<div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
  html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">';
  
  html += '<div>';
  html += '<div style="font-size: 24px; font-weight: bold; color: #28a745;">' + progreso.temasCompletados + '</div>';
  html += '<div style="font-size: 12px; color: #666;">Temas completados</div>';
  html += '</div>';
  
  html += '<div>';
  html += '<div style="font-size: 24px; font-weight: bold; color: #007bff;">' + progreso.horasEstudiadas + 'h</div>';
  html += '<div style="font-size: 12px; color: #666;">Horas estudiadas</div>';
  html += '</div>';
  
  html += '<div>';
  html += '<div style="font-size: 24px; font-weight: bold; color: #ffc107;">' + progreso.repasosPendientes + '</div>';
  html += '<div style="font-size: 12px; color: #666;">Repasos pendientes</div>';
  html += '</div>';
  
  html += '</div>';
  html += '</div>';
  
  html += '<p style="color: #856404; margin-bottom: 30px;">¬øQu√© quieres hacer con esta oposici√≥n?</p>';
  
  // Opciones
  html += '<div style="display: flex; flex-direction: column; gap: 15px; max-width: 400px; margin: 0 auto;">';
  
  html += '<button onclick="marcarOposicionComoInterrumpida()" ';
  html += 'style="background: #ffc107; color: #212529; border: none; padding: 15px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">';
  html += '‚è∏Ô∏è Marcar como INTERRUMPIDA y cambiar';
  html += '<br><small style="font-weight: normal;">Podr√°s retomarla m√°s tarde</small>';
  html += '</button>';
  
  html += '<button onclick="marcarOposicionComoFinalizada()" ';
  html += 'style="background: #28a745; color: white; border: none; padding: 15px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">';
  html += '‚úÖ Marcar como FINALIZADA y cambiar';
  html += '<br><small style="font-weight: normal;">La has terminado o abandonado definitivamente</small>';
  html += '</button>';
  
  html += '<button onclick="cancelarCambioOposicion()" ';
  html += 'style="background: #6c757d; color: white; border: none; padding: 15px 20px; border-radius: 8px; cursor: pointer; font-weight: bold;">';
  html += '‚ùå Cancelar cambio';
  html += '<br><small style="font-weight: normal;">Seguir con la oposici√≥n actual</small>';
  html += '</button>';
  
  html += '</div>';
  html += '</div>';
  html += '</div>';
  
  contenedor.innerHTML = html;
}

// 40. Marcar oposici√≥n como interrumpida
function marcarOposicionComoInterrumpida() {
  const confirmar = confirm('¬øEst√°s seguro de marcar "' + oposicionActiva.nombre + '" como INTERRUMPIDA?\n\n' +
                           'Esto significa que la pausas temporalmente pero podr√°s retomarla m√°s tarde.');
  
  if (!confirmar) return;
  
  google.script.run
    .withSuccessHandler(function() {
      alert('Oposici√≥n marcada como interrumpida correctamente');
      mostrarSelectorNuevaOposicion();
    })
    .withFailureHandler(function(error) {
      console.error('Error al marcar como interrumpida:', error);
      alert('Error al marcar oposici√≥n como interrumpida');
    })
    .cambiarEstadoOposicion(oposicionActiva.id, 'interrumpida');
}

// 41. Marcar oposici√≥n como finalizada
function marcarOposicionComoFinalizada() {
  const confirmar = confirm('¬øEst√°s seguro de marcar "' + oposicionActiva.nombre + '" como FINALIZADA?\n\n' +
                           'Esto significa que la has terminado o abandonado definitivamente.');
  
  if (!confirmar) return;
  
  google.script.run
    .withSuccessHandler(function() {
      alert('Oposici√≥n marcada como finalizada correctamente');
      mostrarSelectorNuevaOposicion();
    })
    .withFailureHandler(function(error) {
      console.error('Error al marcar como finalizada:', error);
      alert('Error al marcar oposici√≥n como finalizada');
    })
    .cambiarEstadoOposicion(oposicionActiva.id, 'finalizada');
}

// 42. Mostrar selector de nueva oposici√≥n (despu√©s de confirmar cambio)
function mostrarSelectorNuevaOposicion() {
  const contenedor = document.getElementById('contenidoPrincipalPlanificacion');
  
  let html = '<div style="text-align: center; padding: 40px;">';
  html += '<h3>Seleccionar nueva oposici√≥n activa</h3>';
  
  if (oposicionActiva) {
    html += '<p style="color: #666; margin-bottom: 30px;">Anterior: <strong>' + oposicionActiva.nombre + '</strong></p>';
  }
  
  html += '<div style="max-width: 400px; margin: 0 auto;">';
  html += '<label style="display: block; margin-bottom: 10px; text-align: left;">Nueva oposici√≥n:</label>';
  html += '<select id="selectorNuevaOposicion" style="width: 100%; padding: 10px; margin-bottom: 20px;">';
  html += '<option value="">-- Selecciona una oposici√≥n --</option>';
  html += '</select>';
  
  html += '<div style="display: flex; gap: 10px; justify-content: center;">';
  html += '<button onclick="cancelarCambioOposicion()" ';
  html += 'style="background: #6c757d; color: white; border: none; padding: 12px 20px; border-radius: 5px; cursor: pointer;">';
  html += 'Cancelar</button>';
  
  html += '<button onclick="confirmarCambioOposicion()" ';
  html += 'style="background: #007bff; color: white; border: none; padding: 12px 20px; border-radius: 5px; cursor: pointer;">';
  html += 'Establecer como activa</button>';
  html += '</div>';
  html += '</div>';
  html += '</div>';
  
  contenedor.innerHTML = html;
  
  // Cargar oposiciones disponibles
  cargarOposicionesParaCambio();
}

// 43. Cargar oposiciones disponibles (excluyendo finalizadas y la actual)
function cargarOposicionesParaCambio() {
  google.script.run
    .withSuccessHandler(function(oposiciones) {
      const select = document.getElementById('selectorNuevaOposicion');
      
      oposiciones.forEach(function(op) {
        // Excluir la actual y las finalizadas
        if (op.estado !== 'finalizada' && (!oposicionActiva || op.id != oposicionActiva.id)) {
          const option = document.createElement('option');
          option.value = op.id;
          option.textContent = op.nombre + (op.estado === 'interrumpida' ? ' (Interrumpida)' : '');
          select.appendChild(option);
        }
      });
      
      if (select.options.length === 1) { // Solo la opci√≥n por defecto
        select.innerHTML = '<option value="">-- No hay otras oposiciones disponibles --</option>';
        document.querySelector('button[onclick="confirmarCambioOposicion()"]').disabled = true;
      }
    })
    .withFailureHandler(function(error) {
      console.error('Error al cargar oposiciones:', error);
      alert('Error al cargar oposiciones');
    })
    .getOposicionesOrdenadas();
}

// 44. Confirmar cambio de oposici√≥n (actualizado)
function confirmarCambioOposicion() {
  const idNuevaOposicion = document.getElementById('selectorNuevaOposicion').value;
  
  if (!idNuevaOposicion) {
    alert('Selecciona una oposici√≥n');
    return;
  }
  
  google.script.run
    .withSuccessHandler(function() {
      alert('Oposici√≥n cambiada correctamente');
      // Recargar la p√°gina principal con la nueva oposici√≥n
      cargarOposicionActiva();
    })
    .withFailureHandler(function(error) {
      console.error('Error al cambiar oposici√≥n:', error);
      alert('Error al cambiar oposici√≥n');
    })
    .setOposicionActiva(idNuevaOposicion);
}

// 45. Configurar event listeners para horas
function setupEventListenerHoras() {
  console.log('üîß Configurando event listener para horas...');
  
  const horasInput = document.getElementById('horasEstudio');
  
  if (!horasInput) {
    console.error('‚ùå Input de horas no encontrado');
    return;
  }
  
  // Remover listeners anteriores para evitar duplicados
  horasInput.removeEventListener('input', actualizarCalculoTiempo);
  horasInput.removeEventListener('change', actualizarCalculoTiempo);
  
  // A√±adir nuevos listeners
  horasInput.addEventListener('input', function() {
    console.log('‚ö° Input de horas cambiado:', this.value);
    actualizarCalculoTiempo();
  });
  
  horasInput.addEventListener('change', function() {
    console.log('‚ö° Change de horas:', this.value);
    actualizarCalculoTiempo();
  });
  
  // Validaci√≥n en tiempo real
  horasInput.addEventListener('input', function() {
    const valor = parseFloat(this.value);
    if (valor < 0.5) {
      this.style.borderColor = '#dc3545';
      this.title = 'M√≠nimo 0.5 horas';
    } else if (valor > 12) {
      this.style.borderColor = '#ffc107';
      this.title = 'M√°ximo recomendado: 12 horas';
    } else {
      this.style.borderColor = '#28a745';
      this.title = '';
    }
  });
  
  console.log('‚úÖ Event listeners configurados correctamente');
}

// 46. Funci√≥n para mostrar paso 2
function mostrarPaso2() {
  console.log('üîß Iniciando paso 2');
  console.log('üìä Repasos del d√≠a:', window.repasosDelDia);
  
  // Cargar configuraci√≥n actual si hay oposici√≥n activa
  if (oposicionActiva) {
    cargarConfiguracionActual();
  } else {
    // Valores por defecto si no hay configuraci√≥n
    document.getElementById('vueltaActual').textContent = '1';
    document.getElementById('minutosPorPagina').textContent = '30';
  }
  
  // Mostrar repasos en el paso 2
  mostrarRepasosEnPasoDos();
  
  // Establecer valor por defecto de horas si est√° vac√≠o
  const horasInput = document.getElementById('horasEstudio');
  if (horasInput && !horasInput.value) {
    horasInput.value = '4';
    console.log('‚úÖ Establecido valor por defecto: 4 horas');
  }
  
  // Configurar event listener para cambios de horas
  setupEventListenerHoras();
  
  // Calcular tiempo inicial
  actualizarCalculoTiempo();
  
  console.log('‚úÖ Paso 2 completado');
}

// 47. Renderizar √°rbol con temas pre-seleccionados marcados
// CORRECCI√ìN 41: En scriptsPlanificacion.html
// Reemplazar la funci√≥n renderizarArbolConTemasPreseleccionados() existente

function renderizarArbolConTemasPreseleccionados(arbolTemas, minutosPorPagina, bloquesInfo) {
  const contenedor = document.getElementById('arbolTemas');
  
  if (!arbolTemas || arbolTemas.length === 0) {
    contenedor.innerHTML = '<p style="text-align: center; color: #666;">No hay temas vinculados a esta oposici√≥n</p>';
    return;
  }
  
  // Agrupar temas por bloque
  const temasPorBloque = agruparTemasPorBloque(arbolTemas, bloquesInfo);
  
  let html = '';
  
  // Renderizar cada bloque
  Object.keys(temasPorBloque).forEach(nombreBloque => {
    const temasDelBloque = temasPorBloque[nombreBloque];
    const esEspecial = esBloqueBloqueEspecial(nombreBloque);
    
    html += '<div style="margin-bottom: 20px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">';
    
    // Header del bloque (colapsable)
    html += '<div onclick="toggleBloqueCompleto(\'' + nombreBloque + '\')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee;">';
    html += '<div>';
    html += '<h6 style="margin: 0; font-weight: bold;">' + nombreBloque;
    if (esEspecial) {
      html += ' <span style="background: #ffc107; color: #212529; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin-left: 8px;">ESPECIAL</span>';
    }
    html += '</h6>';
    html += '<small style="color: #666;">' + temasDelBloque.length + ' temas principales | ';
    html += 'L√≠mite: ' + (esEspecial ? '1 especial' : '3 normales') + '</small>';
    html += '</div>';
    html += '<i id="icono-bloque-' + nombreBloque + '" style="transition: transform 0.3s;">‚ñº</i>';
    html += '</div>';
    
    // Contenido del bloque (inicialmente visible)
    html += '<div id="bloque-' + nombreBloque + '" style="padding: 15px;">';
    
    // NUEVA VISUALIZACI√ìN: Informaci√≥n de reglas del bloque
    html += '<div style="background: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 12px;">';
    html += '<strong>üìã Reglas para este bloque:</strong><br>';
    html += '‚Ä¢ Solo un tema padre original por bloque<br>';
    html += '‚Ä¢ Orden secuencial dentro del tema padre original<br>';
    html += '‚Ä¢ Temas colapsados: haz clic en ‚ñ∂ para expandir y ver opciones';
    html += '</div>';
    
    // Renderizar cada tema del bloque con nueva visualizaci√≥n
    temasDelBloque.forEach(tema => {
      html += renderizarNodoTemaConPreseleccion(tema, 0, nombreBloque);
    });
    
    html += '</div>';
    html += '</div>';
  });
  
  contenedor.innerHTML = html;
  
  // Expandir autom√°ticamente temas con selecciones despu√©s del renderizado
  setTimeout(() => {
    expandirTemasConSelecciones();
    actualizarResumenTiempo();
  }, 100);
}

// Nueva funci√≥n para colapsar bloque completo
function toggleBloqueCompleto(nombreBloque) {
  const contenido = document.getElementById('bloque-' + nombreBloque);
  const icono = document.getElementById('icono-bloque-' + nombreBloque);
  
  if (contenido && icono) {
    if (contenido.style.display === 'none') {
      contenido.style.display = 'block';
      icono.textContent = '‚ñº';
      console.log('üìÇ Bloque expandido:', nombreBloque);
    } else {
      contenido.style.display = 'none';
      icono.textContent = '‚ñ∂';
      console.log('üìÅ Bloque colapsado:', nombreBloque);
    }
  }
}

// CORRECCI√ìN FINAL: En scriptsPlanificacion.html
// Reemplazar la funci√≥n mostrarInformacionDeReglasActualizada() de la Correcci√≥n 41
// Y cambiar su nombre a mostrarInformacionDeReglas()

function mostrarInformacionDeReglas() {
  const contenedorInfo = document.createElement('div');
  contenedorInfo.id = 'informacionReglas';
  contenedorInfo.style.cssText = `
    background: #e3f2fd; 
    border-left: 4px solid #2196f3; 
    padding: 15px; 
    margin-bottom: 20px; 
    border-radius: 5px;
    font-size: 14px;
  `;
  
  contenedorInfo.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: start;">
      <div style="flex: 1;">
        <h5 style="margin: 0 0 10px 0; color: #0d47a1;">üìã Reglas de selecci√≥n (CORREGIDAS)</h5>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
          <div style="background: white; padding: 10px; border-radius: 5px;">
            <strong>üì¶ L√≠mites de bloques:</strong><br>
            ‚Ä¢ M√°ximo 3 bloques normales<br>
            ‚Ä¢ + 1 bloque especial (Geograf√≠a/Callejero)
          </div>
          <div style="background: white; padding: 10px; border-radius: 5px;">
            <strong>üë®‚Äçüëß‚Äçüë¶ Un tema padre por bloque:</strong><br>
            ‚Ä¢ Solo temas de UN tema padre original<br>
            ‚Ä¢ Ejemplo: Solo temas "1.x" o solo "2.x"
          </div>
        </div>
        
        <div style="background: white; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
          <strong>üìä Orden dentro del tema padre:</strong> Seguir orden del √°rbol (1.1 ‚Üí 1.2 ‚Üí 1.3)<br>
          <strong>‚è±Ô∏è Excepci√≥n por tiempo:</strong> Si tema padre no cabe ‚Üí seleccionar hijos en orden
        </div>
        
        <div style="background: white; padding: 10px; border-radius: 5px;">
          <strong>üëÅÔ∏è Visualizaci√≥n:</strong><br>
          ‚Ä¢ <span style="color: #007bff;">‚ñ∂</span> = Expandir para ver opciones<br>
          ‚Ä¢ <span style="color: #28a745;">‚ñº</span> = Colapsar<br>
          ‚Ä¢ Hojas (sin hijos) = checkbox directo
        </div>
        
        <div style="margin-top: 10px; font-size: 12px; color: #666;">
          üí° <strong>Advertencias:</strong> 1¬™ vez = no permite, 2¬™ vez = permite (libertad total)
        </div>
      </div>
      
      <div style="margin-left: 20px;">
        <button onclick="mostrarDebugEstado()" style="background: #ff9800; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; margin-bottom: 5px; display: block; width: 100%;">
          üêõ Debug Estado
        </button>
        <button onclick="repararEstadoSeleccion()" style="background: #f44336; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; margin-bottom: 5px; display: block; width: 100%;">
          üîß Reparar Estado
        </button>
        <button onclick="expandirTodosLosTemas()" style="background: #4caf50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; display: block; width: 100%;">
          üìÇ Expandir Todos
        </button>
      </div>
    </div>
  `;
  
  // Insertar antes del √°rbol de temas
  const arbolTemas = document.getElementById('arbolTemas');
  if (arbolTemas && !document.getElementById('informacionReglas')) {
    arbolTemas.parentElement.insertBefore(contenedorInfo, arbolTemas);
  }
}

// Nueva funci√≥n para expandir todos los temas
function expandirTodosLosTemas() {
  console.log('üìÇ Expandiendo todos los temas...');
  
  // Expandir todos los bloques
  const iconosBloque = document.querySelectorAll('[id^="icono-bloque-"]');
  iconosBloque.forEach(icono => {
    const nombreBloque = icono.id.replace('icono-bloque-', '');
    const contenido = document.getElementById('bloque-' + nombreBloque);
    if (contenido && contenido.style.display === 'none') {
      contenido.style.display = 'block';
      icono.textContent = '‚ñº';
    }
  });
  
  // Expandir todos los temas
  const iconosTema = document.querySelectorAll('[onclick^="toggleColapsarTema"]');
  iconosTema.forEach(icono => {
    if (icono.textContent === '‚ñ∂') {
      icono.click(); // Simular clic para expandir
    }
  });
  
  console.log('‚úÖ Todos los temas expandidos');
}

// 48. Forzar renderizado inicial del calendario
function inicializarCalendarioPlanificacion() {
  if (document.getElementById('calendario')) {
    renderizarCalendario();
    // Auto-seleccionar d√≠a actual si estamos en el mes actual
    const hoy = new Date();
    if (mesActual.getMonth() === hoy.getMonth() && mesActual.getFullYear() === hoy.getFullYear()) {
      setTimeout(() => {
        seleccionarDia(hoy.getDate());
      }, 100);
    }
  }
}



// Renderizar calendario
function renderizarCalendario() {
  const a√±o = mesActual.getFullYear();
  const mes = mesActual.getMonth();
  
  // Actualizar t√≠tulo
  const meses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
  document.getElementById('tituloMes').textContent = meses[mes] + ' ' + a√±o;
  
  // Calcular primer d√≠a (lunes = 0)
  let primerDia = new Date(a√±o, mes, 1).getDay();
  primerDia = primerDia === 0 ? 6 : primerDia - 1; // Ajustar para lunes = 0
  
  const diasEnMes = new Date(a√±o, mes + 1, 0).getDate();
  const hoy = new Date();
  
  // Generar HTML del calendario
  let html = '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px;">';
  
  // Encabezados de d√≠as
  const diasSemana = ['Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b', 'Dom'];
  diasSemana.forEach(dia => {
    html += '<div style="text-align: center; font-weight: bold; padding: 8px; color: #666; font-size: 12px;">' + dia + '</div>';
  });
  
  // D√≠as vac√≠os al inicio
  for (let i = 0; i < primerDia; i++) {
    html += '<div></div>';
  }
  
  //D√≠as del mes
  for (let dia = 1; dia <= diasEnMes; dia++) {
    const fecha = new Date(a√±o, mes, dia);
    const esHoy = fecha.toDateString() === hoy.toDateString();
    const esSeleccionado = diaSeleccionado === dia;
    
    // Estilos del d√≠a
    let estilos = 'min-height: 80px; border: 1px solid #ddd; border-radius: 5px; padding: 5px; cursor: pointer; ';
    estilos += 'display: flex; flex-direction: column; justify-content: space-between; ';
    
    if (esHoy) {
      estilos += 'border: 2px solid #2196f3; background: #e3f2fd; ';
    } else if (esSeleccionado) {
      estilos += 'background: #f0f0f0; ';
    } else {
      estilos += 'background: white; ';
    }
    
    html += '<div onclick="seleccionarDia(' + dia + ')" style="' + estilos + '">';
    
    // N√∫mero del d√≠a
    html += '<div style="font-weight: bold; color: ' + (esHoy ? '#2196f3' : '#333') + ';">' + dia + '</div>';
    
    // Contenido del d√≠a (placeholder por ahora)
    html += '<div id="contenido-' + a√±o + '-' + mes + '-' + dia + '" style="font-size: 10px; flex: 1;"></div>';
    
    html += '</div>';
  }
  
  html += '</div>';
  
  document.getElementById('calendario').innerHTML = html;
}


// Cambiar mes
function cambiarMes(direccion) {
  mesActual.setMonth(mesActual.getMonth() + direccion);
  diaSeleccionado = null; // Reset selecci√≥n
  renderizarCalendario();
  limpiarDetalleDia();
}

// Ir a hoy
function irAHoy() {
  mesActual = new Date();
  renderizarCalendario();
  seleccionarDia(new Date().getDate());
}

// Seleccionar d√≠a
function seleccionarDia(dia) {
  const fechaSeleccionada = new Date(mesActual.getFullYear(), mesActual.getMonth(), dia);
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  fechaSeleccionada.setHours(0, 0, 0, 0);
  
  const esDiaPasado = fechaSeleccionada < hoy;
  
  diaSeleccionado = dia;
  renderizarCalendario(); // Re-renderizar para mostrar selecci√≥n
  
  // Actualizar detalle del d√≠a
  const opciones = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  const tituloFecha = fechaSeleccionada.toLocaleDateString('es-ES', opciones);
  
  if (esDiaPasado) {
    document.getElementById('tituloDetalleDia').textContent = tituloFecha + ' (Solo lectura)';
    document.getElementById('contenidoDetalleDia').innerHTML = 
      '<div style="background: #fff3cd; padding: 15px; border-radius: 5px; border-left: 4px solid #ffc107; margin-bottom: 15px;">' +
      '<strong>‚ÑπÔ∏è D√≠a pasado:</strong> Solo puedes consultar la informaci√≥n, no modificar.' +
      '</div>' +
      '<p style="color: #999;">Detalle del d√≠a en desarrollo...</p>';
  } else {
    document.getElementById('tituloDetalleDia').textContent = tituloFecha;
    document.getElementById('contenidoDetalleDia').innerHTML = 
      '<p style="color: #999;">D√≠a seleccionado: ' + dia + '. Detalle en desarrollo...</p>';
  }
}

// Limpiar detalle del d√≠a
function limpiarDetalleDia() {
  document.getElementById('tituloDetalleDia').textContent = 'Selecciona un d√≠a';
  document.getElementById('contenidoDetalleDia').innerHTML = '<p style="text-align: center; color: #666; padding: 40px 0;"><i class="fas fa-calendar-alt" style="font-size: 48px; opacity: 0.3;"></i><br>Selecciona un d√≠a del calendario</p>';
}

// Abrir modal de nueva planificaci√≥n
// CORRECCI√ìN 22: En scriptsPlanificacion.html
// Reemplazar la funci√≥n nuevaPlanificacion() existente

function nuevaPlanificacion() {
  // Validar que hay un d√≠a seleccionado
  if (!diaSeleccionado) {
    alert('‚ö†Ô∏è Primero selecciona un d√≠a del calendario');
    return;
  }
  
  // Validar que no es d√≠a pasado
  const fechaSeleccionada = new Date(mesActual.getFullYear(), mesActual.getMonth(), diaSeleccionado);
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  fechaSeleccionada.setHours(0, 0, 0, 0);
  
  if (fechaSeleccionada < hoy) {
    alert('‚ö†Ô∏è No puedes crear planificaciones para d√≠as pasados');
    return;
  }
  
  // Reset variables
  pasoActual = 1;
  temasSeleccionados = [];
  tiempoUsado = 0;
  bloquesActivos = [];
  
  // üîÑ NUEVO: Resetear advertencias para empezar limpio
  resetearAdvertencias();
  
  // Limpiar modo comparaci√≥n si existe
  window.modoCreacionPlanificacion = 'normal';
  window.temasParaPlanificar = null;
  
  // Mostrar modal
  document.getElementById('modalNuevaPlanificacion').style.display = 'flex';
  
  // Mostrar paso 1
  mostrarPaso(1);
  
  // ‚úÖ Establecer fecha autom√°ticamente DESPU√âS de mostrar el paso
  setTimeout(function() {
    const fechaStr = fechaSeleccionada.getFullYear() + '-' + 
      String(fechaSeleccionada.getMonth() + 1).padStart(2, '0') + '-' + 
      String(fechaSeleccionada.getDate()).padStart(2, '0');
    
    const inputFecha = document.getElementById('fechaPlanificacion');
    if (inputFecha) {
      inputFecha.value = fechaStr;
      console.log('‚úÖ Fecha establecida autom√°ticamente:', fechaStr);
      
      // Verificar repasos despu√©s de establecer la fecha
      verificarRepasosDelDia();
    } else {
      console.error('‚ùå No se encontr√≥ el input de fecha');
    }
  }, 200); // Dar tiempo para que se renderice el paso 1
}

// Cerrar modal
function cerrarModal() {
  document.getElementById('modalNuevaPlanificacion').style.display = 'none';
}

// Mostrar paso espec√≠fico
// CORRECCI√ìN 10: En scriptsPlanificacion.html
// Reemplazar la funci√≥n mostrarPaso() existente

function mostrarPaso(numeroPaso) {
  console.log('üìç Mostrando paso:', numeroPaso);
  
  // GUARDAR fecha actual antes de cambiar de paso
  let fechaGuardada = null;
  const fechaInput = document.getElementById('fechaPlanificacion');
  if (fechaInput && fechaInput.value) {
    fechaGuardada = fechaInput.value;
    console.log('üíæ Fecha guardada:', fechaGuardada);
  }
  
  pasoActual = numeroPaso;
  
  // Ocultar todos los pasos
  document.getElementById('paso1').style.display = 'none';
  document.getElementById('paso2').style.display = 'none';
  document.getElementById('paso3').style.display = 'none';
  
  // Mostrar paso actual
  document.getElementById('paso' + numeroPaso).style.display = 'block';
  
  // Actualizar indicadores visuales
  actualizarIndicadoresPasos();
  
  // Actualizar botones
  document.getElementById('btnAnterior').style.display = numeroPaso > 1 ? 'inline-block' : 'none';
  document.getElementById('btnSiguiente').textContent = numeroPaso === 3 ? 'Crear Planificaci√≥n' : 'Siguiente ‚ñ∂';
  
  // Acciones espec√≠ficas por paso
  if (numeroPaso === 1) {
    mostrarPaso1(); 
    
    // ‚úÖ RESTAURAR fecha despu√©s de renderizar
    setTimeout(function() {
      const nuevaFechaInput = document.getElementById('fechaPlanificacion');
      if (nuevaFechaInput && fechaGuardada) {
        nuevaFechaInput.value = fechaGuardada;
        console.log('üîÑ Fecha restaurada:', fechaGuardada);
        
        // Verificar repasos de la fecha restaurada
        verificarRepasosDelDia();
      }
    }, 100);
    
  } else if (numeroPaso === 2) {
    mostrarPaso2();
    setupEventListenerHoras();
    
  } else if (numeroPaso === 3) {
    console.log('üìç Iniciando paso 3 con reglas correctas y visualizaci√≥n colapsada');
    
    // Obtener tiempo real disponible del paso 2
    const tiempoRealParaTemas = window.tiempoRealParaTemas || 0;
    tiempoTotalDisponible = tiempoRealParaTemas;
    
    console.log('‚è±Ô∏è Tiempo disponible para paso 3:', tiempoTotalDisponible, 'min');
    
    // Pre-cargar temas de comparaci√≥n si existen
    if (window.temasParaPlanificar && window.temasParaPlanificar.temas) {
      console.log('üîÑ Pre-cargando temas de comparaci√≥n...');
      precargarTemasDeComparacion();
    }
    
    // Cargar √°rbol de temas con nueva visualizaci√≥n
    cargarArbolTemasCorregido();
    
    // Mostrar informaci√≥n de reglas actualizada y configurar visualizaci√≥n
    setTimeout(() => {
      console.log('üé® Configurando interfaz del paso 3...');
      
      // Mostrar informaci√≥n de reglas actualizada
      mostrarInformacionDeReglas();
      
      // Expandir autom√°ticamente temas con selecciones previas
      if (temasSeleccionados.length > 0) {
        expandirTemasConSelecciones();
        console.log('üìÇ Temas con selecciones previas expandidos');
      }
      
      // Actualizar resumen de tiempo
      actualizarResumenTiempo();
      
      // Verificar estado autom√°ticamente
      verificarEstadoAutomaticamente();
      
      console.log('‚úÖ Paso 3 configurado correctamente');
    }, 500);
  }
}

// Actualizar indicadores de pasos
function actualizarIndicadoresPasos() {
  for (let i = 1; i <= 3; i++) {
    const indicador = document.getElementById('indicadorPaso' + i);
    const circulo = indicador.querySelector('div');
    const texto = indicador.querySelector('span');
    
    if (i < pasoActual) {
      // Paso completado
      circulo.style.background = '#28a745';
      circulo.style.color = 'white';
      texto.style.color = '#28a745';
    } else if (i === pasoActual) {
      // Paso actual
      circulo.style.background = '#007bff';
      circulo.style.color = 'white';
      texto.style.color = '#007bff';
    } else {
      // Paso pendiente
      circulo.style.background = '#ddd';
      circulo.style.color = '#999';
      texto.style.color = '#999';
    }
  }
}

// Paso siguiente
function pasoSiguiente() {
  if (pasoActual === 1) {
    // Validar paso 1
    if (!document.getElementById('fechaPlanificacion').value) {
      alert('‚ö†Ô∏è Selecciona una fecha');
      return;
    }
    /*
    if (!document.getElementById('oposicionPlanificacion').value) {
      alert('‚ö†Ô∏è Selecciona una oposici√≥n');
      return;
    }
    */
    mostrarPaso(2);
    
    } else if (pasoActual === 2) {
      // Validar paso 2 con nueva funci√≥n
      if (!validarPaso2()) {
        return;
      }
      mostrarPaso(3);
    } else if (pasoActual === 3) {
    // Crear planificaci√≥n
    crearPlanificacion();
  }
}

// Paso anterior
function pasoAnterior() {
  if (pasoActual > 1) {
    mostrarPaso(pasoActual - 1);
  }
}

// Cargar oposiciones (conectado al backend)
function cargarOposiciones() {
  const select = document.getElementById('oposicionPlanificacion');
  select.innerHTML = '<option value="">-- Cargando oposiciones... --</option>';
  
  google.script.run
    .withSuccessHandler(function(oposiciones) {
      select.innerHTML = '<option value="">-- Selecciona una oposici√≥n --</option>';
      
      oposiciones.forEach(function(oposicion) {
        const option = document.createElement('option');
        option.value = oposicion.id;
        option.textContent = oposicion.nombre;
        select.appendChild(option);
      });
    })
    .withFailureHandler(function(error) {
      console.error('Error al cargar oposiciones:', error);
      select.innerHTML = '<option value="">-- Error al cargar --</option>';
    })
    .getOposicionesParaPlanificacion();
}

// Verificar repasos del d√≠a con indicador de carga
// CORRECCI√ìN 3: En scriptsPlanificacion.html
// Reemplazar la funci√≥n verificarRepasosDelDia() existente

function verificarRepasosDelDia() {
  const fechaInput = document.getElementById('fechaPlanificacion');
  if (!fechaInput || !fechaInput.value) {
    console.log('‚ùå No hay fecha seleccionada');
    const alertaDiv = document.getElementById('alertaRepasos');
    if (alertaDiv) alertaDiv.style.display = 'none';
    return;
  }
  
  const fecha = fechaInput.value;
  const fechaMs = new Date(fecha + 'T00:00:00').getTime();
  
  console.log('üîç Verificando repasos para fecha:', fecha);
  console.log('üîç Fecha en ms:', fechaMs);
  
  // Mostrar loading en el contenedor de repasos
  const alertaDiv = document.getElementById('alertaRepasos');
  const listaDiv = document.getElementById('listaRepasos');
  
  if (alertaDiv && listaDiv) {
    alertaDiv.style.display = 'block';
    listaDiv.innerHTML = '<p style="margin: 0;"><i class="fas fa-spinner fa-spin"></i> Verificando repasos...</p>';
  }
  
  google.script.run
    .withSuccessHandler(function(repasos) {
      console.log('‚úÖ Repasos recibidos:', repasos);
      
      // Guardar repasos globalmente
      window.repasosDelDia = repasos || [];
      
      if (!alertaDiv || !listaDiv) {
        console.error('‚ùå Elementos de repasos no encontrados');
        return;
      }
      
      if (repasos && repasos.length > 0) {
        // Mostrar repasos encontrados
        let html = '';
        let tiempoTotal = 0;
        
        repasos.forEach(function(repaso) {
          html += '<div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #ffeaa7;">';
          html += '<div><strong>R' + repaso.numeroRepaso + ':</strong> ' + repaso.nombreTema + '</div>';
          html += '<div style="color: #856404; font-size: 12px;">' + (repaso.tiempoEstimado || 30) + ' min</div>';
          html += '</div>';
          tiempoTotal += (repaso.tiempoEstimado || 30);
        });
        
        html += '<div style="text-align: right; margin-top: 10px; font-weight: bold; color: #856404;">';
        html += 'Total repasos: ' + tiempoTotal + ' minutos (' + Math.round(tiempoTotal / 60 * 10) / 10 + ' horas)';
        html += '</div>';
        
        listaDiv.innerHTML = html;
        alertaDiv.style.display = 'block';
        
        console.log('‚úÖ Repasos mostrados:', repasos.length, 'repasos,', tiempoTotal, 'minutos');
      } else {
        // No hay repasos
        alertaDiv.style.display = 'none';
        console.log('‚úÖ No hay repasos para este d√≠a');
      }
      
      // Habilitar bot√≥n siguiente
      const btnSiguiente = document.getElementById('btnSiguiente');
      if (btnSiguiente) btnSiguiente.disabled = false;
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al cargar repasos:', error);
      window.repasosDelDia = [];
      
      if (alertaDiv && listaDiv) {
        listaDiv.innerHTML = '<p style="margin: 0; color: red;">Error al cargar repasos: ' + error.message + '</p>';
        alertaDiv.style.display = 'block';
      }
      
      // Habilitar bot√≥n siguiente aunque haya error
      const btnSiguiente = document.getElementById('btnSiguiente');
      if (btnSiguiente) btnSiguiente.disabled = false;
    })
    .getRepasosDelDia(fechaMs);
}

// CORRECCI√ìN 37: En scriptsPlanificacion.html
// Reemplazar la funci√≥n validarSeleccionTema() existente

function validarSeleccionTema(tiempoMinutos, nombreBloque) {
  console.log('‚è±Ô∏è Validando l√≠mites para:', tiempoMinutos, 'min en bloque', nombreBloque);
  console.log('üìä Tiempo actual usado:', tiempoUsado, '/ Disponible:', tiempoTotalDisponible);
  
  // VALIDACI√ìN 1: Verificar tiempo disponible (restrictiva)
  if (tiempoUsado + tiempoMinutos > tiempoTotalDisponible) {
    const exceso = (tiempoUsado + tiempoMinutos - tiempoTotalDisponible);
    return {
      valido: false,
      mensaje: 'Excede el tiempo disponible üïí\n\n' +
               'Tiempo disponible: ' + formatearTiempo(tiempoTotalDisponible) + '\n' +
               'Ya usado: ' + formatearTiempo(tiempoUsado) + '\n' +
               'Este tema: ' + formatearTiempo(tiempoMinutos) + '\n' +
               'Exceso: ' + formatearTiempo(exceso) + '\n\n' +
               'üí° Soluciones:\n' +
               '‚Ä¢ Aumenta las horas de estudio en el Paso 2\n' +
               '‚Ä¢ Selecciona menos temas o m√°s cortos\n' +
               '‚Ä¢ Revisa si hay repasos que reduzcan el tiempo'
    };
  }
  
  // VALIDACI√ìN 2: Verificar l√≠mites de bloques (con advertencias)
  if (!bloquesActivos.includes(nombreBloque)) {
    const esEspecial = esBloqueBloqueEspecial(nombreBloque);
    const bloquesNormales = bloquesActivos.filter(b => !esBloqueBloqueEspecial(b));
    const bloquesEspeciales = bloquesActivos.filter(b => esBloqueBloqueEspecial(b));
    
    console.log('üìä An√°lisis de bloques:', {
      normales: bloquesNormales,
      especiales: bloquesEspeciales,
      nuevoEsEspecial: esEspecial,
      totalActual: bloquesActivos.length
    });
    
    // REGLA CORRECTA: M√°ximo 3 normales + 1 especial
    let mensajeAdvertencia = '';
    let claveAdvertencia = '';
    let debeAdvertir = false;
    
    if (!esEspecial && bloquesNormales.length >= 3) {
      mensajeAdvertencia = 'L√≠mite de bloques normales alcanzado üìö\n\n' +
                          'Ya tienes 3 bloques normales (l√≠mite m√°ximo):\n' +
                          bloquesNormales.join(', ') + '\n\n' +
                          'Nuevo bloque: ' + nombreBloque + '\n\n' +
                          'Solo puedes tener 3 bloques normales por d√≠a.\n' +
                          'Puedes a√±adir 1 bloque especial (Geograf√≠a/Callejero) adicional.';
      claveAdvertencia = `limite_bloques_normales_${nombreBloque}`;
      debeAdvertir = true;
      
    } else if (esEspecial && bloquesEspeciales.length >= 1) {
      mensajeAdvertencia = 'L√≠mite de bloques especiales alcanzado üéØ\n\n' +
                          'Ya tienes 1 bloque especial (l√≠mite m√°ximo):\n' +
                          bloquesEspeciales.join(', ') + '\n\n' +
                          'Nuevo bloque: ' + nombreBloque + '\n\n' +
                          'Solo puedes tener 1 bloque especial (Geograf√≠a/Callejero) por d√≠a.';
      claveAdvertencia = `limite_bloques_especiales_${nombreBloque}`;
      debeAdvertir = true;
      
    } else if (bloquesActivos.length >= 4) {
      mensajeAdvertencia = 'L√≠mite total de bloques alcanzado üß†\n\n' +
                          'Ya tienes 4 bloques (l√≠mite m√°ximo del sistema):\n' +
                          bloquesActivos.join(', ') + '\n\n' +
                          'Nuevo bloque: ' + nombreBloque + '\n\n' +
                          'L√≠mite: 3 bloques normales + 1 especial = 4 total m√°ximo.';
      claveAdvertencia = `limite_bloques_totales_${nombreBloque}`;
      debeAdvertir = true;
    }
    
    if (debeAdvertir) {
      // Usar sistema de advertencias de dos niveles
      const permitido = manejarAdvertenciaConDobleNivel('bloques', claveAdvertencia, mensajeAdvertencia);
      
      if (!permitido) {
        return {
          valido: false,
          mensaje: 'L√≠mite de bloques - primera advertencia mostrada'
        };
      }
      // Si permitido = true, continuar
    }
  }
  
  console.log('‚úÖ Validaciones de l√≠mites de bloques pasadas');
  return { valido: true };
}

// CORRECCI√ìN 33: En scriptsPlanificacion.html
// Reemplazar la funci√≥n seleccionarHijosAutomaticamente() existente

function seleccionarHijosAutomaticamente(idTemaPadre, nombreBloque) {
  console.log('üîÑ Seleccionando hijos autom√°ticamente para tema padre:', idTemaPadre);
  
  // Encontrar el nodo del tema padre
  const nodoTemaPadre = encontrarNodoEnArbolCompleto(idTemaPadre, window.arbolCompletoGlobal);
  if (!nodoTemaPadre || !nodoTemaPadre.hijos || nodoTemaPadre.hijos.length === 0) {
    console.log('‚ùå No es tema padre o no tiene hijos');
    return [];
  }
  
  // Recopilar todos los hijos (incluyendo nietos, bisnietos, etc.)
  const todosLosHijos = obtenerTodosLosDescendientes(nodoTemaPadre, window.arbolCompletoGlobal);
  
  console.log('üë∂ Hijos encontrados:', todosLosHijos.map(h => h.nombreCompleto));
  
  // Marcar checkboxes de todos los hijos en la interfaz
  const hijosSeleccionados = [];
  
  todosLosHijos.forEach(hijo => {
    // CORRECCI√ìN: Buscar checkbox usando m√©todo m√°s robusto
    const checkboxEncontrado = encontrarCheckboxPorIdTema(hijo.id);
    
    if (checkboxEncontrado) {
      // Marcar como seleccionado
      checkboxEncontrado.checked = true;
      checkboxEncontrado.disabled = true; // Deshabilitar porque se seleccion√≥ autom√°ticamente
      
      // A√±adir estilo visual para indicar que es autom√°tico
      const contenedor = checkboxEncontrado.closest('div[style*="padding"]');
      if (contenedor) {
        contenedor.style.opacity = '0.7';
        contenedor.style.backgroundColor = '#e3f2fd';
        
        // Remover badges anteriores para evitar duplicados
        const badgesAnteriores = contenedor.querySelectorAll('.badge-auto');
        badgesAnteriores.forEach(badge => badge.remove());
        
        // A√±adir badge "AUTO"
        const badge = document.createElement('span');
        badge.className = 'badge-auto';
        badge.textContent = 'AUTO';
        badge.style.cssText = 'background: #2196f3; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 10px;';
        checkboxEncontrado.parentElement.appendChild(badge);
      }
      
      hijosSeleccionados.push({
        id: hijo.id,
        tiempo: 0, // Tiempo 0 porque se cuenta en el padre
        bloque: nombreBloque,
        tipo: 'hijo_automatico',
        padreId: idTemaPadre
      });
      
      console.log('‚úÖ Hijo marcado autom√°ticamente:', hijo.nombreCompleto);
    } else {
      console.warn('‚ö†Ô∏è No se encontr√≥ checkbox para hijo:', hijo.nombreCompleto, 'ID:', hijo.id);
    }
  });
  
  console.log('üîÑ Total hijos seleccionados autom√°ticamente:', hijosSeleccionados.length);
  return hijosSeleccionados;
}

// Funci√≥n auxiliar mejorada para encontrar checkbox por ID de tema
function encontrarCheckboxPorIdTema(idTema) {
  console.log('üîç Buscando checkbox para tema ID:', idTema);
  
  // Buscar TODOS los checkboxes en la p√°gina
  const todosLosCheckboxes = document.querySelectorAll('input[type="checkbox"]');
  
  for (let checkbox of todosLosCheckboxes) {
    // Extraer ID del tema del atributo onchange
    const onchangeAttr = checkbox.getAttribute('onchange');
    if (onchangeAttr) {
      // Buscar n√∫mero en la funci√≥n onchange: toggleSeleccionTemaConValidacion(this, 123, ...)
      const match = onchangeAttr.match(/toggleSeleccionTemaConValidacion\(this,\s*(\d+)/);
      if (match) {
        const idTemaCheckbox = parseInt(match[1]);
        
        if (idTemaCheckbox === idTema) {
          console.log('‚úÖ Checkbox encontrado para tema:', idTema);
          return checkbox;
        }
      }
    }
  }
  
  console.warn('‚ùå Checkbox no encontrado para tema:', idTema);
  return null;
}

// CORRECCI√ìN 31: En scriptsPlanificacion.html
// Reemplazar la funci√≥n desmarcarHijosAutomaticos() existente

function desmarcarHijosAutomaticos(idTemaPadre) {
  console.log('üîÑ Desmarcando hijos autom√°ticos del tema padre:', idTemaPadre);
  
  // Encontrar y remover temas hijos autom√°ticos de la lista
  const temasARemover = temasSeleccionados.filter(tema => 
    tema.tipo === 'hijo_automatico' && tema.padreId === idTemaPadre
  );
  
  console.log('‚ùå Temas hijos a remover:', temasARemover);
  
  temasARemover.forEach(tema => {
    // Remover de la lista global
    const index = temasSeleccionados.findIndex(t => t.id === tema.id);
    if (index > -1) {
      temasSeleccionados.splice(index, 1);
      console.log('‚ùå Removido de lista:', tema.id);
    }
    
    // CORRECCI√ìN: Desmarcar checkbox correctamente en la interfaz
    limpiarEstadoVisualDeTema(tema.id);
  });
  
  console.log('‚úÖ Hijos autom√°ticos desmarcados completamente');
}

// Nueva funci√≥n para limpiar estado visual de un tema espec√≠fico
function limpiarEstadoVisualDeTema(idTema) {
  console.log('üßπ Limpiando estado visual del tema:', idTema);
  
  // Buscar TODOS los checkboxes en la p√°gina
  const todosLosCheckboxes = document.querySelectorAll('input[type="checkbox"]');
  
  todosLosCheckboxes.forEach(checkbox => {
    // Extraer ID del tema del atributo onchange
    const onchangeAttr = checkbox.getAttribute('onchange');
    if (onchangeAttr) {
      // Buscar n√∫mero en la funci√≥n onchange: toggleSeleccionTemaConValidacion(this, 123, ...)
      const match = onchangeAttr.match(/toggleSeleccionTemaConValidacion\(this,\s*(\d+)/);
      if (match) {
        const idTemaCheckbox = parseInt(match[1]);
        
        if (idTemaCheckbox === idTema) {
          console.log('üéØ Encontrado checkbox para tema:', idTema);
          
          // Desmarcar checkbox
          checkbox.checked = false;
          checkbox.disabled = false;
          
          // Encontrar el contenedor del tema
          const contenedor = checkbox.closest('div[style*="padding"]');
          if (contenedor) {
            // Restaurar estilo normal
            contenedor.style.opacity = '';
            contenedor.style.backgroundColor = '';
            
            // Remover TODOS los badges (AUTO, PRE-SEL, progreso, etc.)
            const badges = contenedor.querySelectorAll('span[style*="background"]');
            badges.forEach(badge => {
              // Solo remover badges que no sean esenciales (como estado del tema)
              const textoDelBadge = badge.textContent;
              if (textoDelBadge.includes('AUTO') || 
                  textoDelBadge.includes('PRE-SEL') || 
                  textoDelBadge.includes('seleccionados')) {
                badge.remove();
                console.log('üóëÔ∏è Badge removido:', textoDelBadge);
              }
            });
          }
          
          console.log('‚úÖ Estado visual limpiado para tema:', idTema);
          return; // Salir del loop una vez encontrado
        }
      }
    }
  });
}

// Nueva funci√≥n para limpiar completamente el estado visual de un tema padre
function limpiarEstadoVisualTemaPadre(idTemaPadre) {
  console.log('üßπ Limpiando estado visual del tema padre:', idTemaPadre);
  
  // Limpiar el tema padre principal
  limpiarEstadoVisualDeTema(idTemaPadre);
  
  // Obtener todos los hijos del tema padre
  const nodoTemaPadre = encontrarNodoEnArbolCompleto(idTemaPadre, window.arbolCompletoGlobal);
  if (nodoTemaPadre) {
    const todosLosHijos = obtenerTodosLosDescendientes(nodoTemaPadre, window.arbolCompletoGlobal);
    
    console.log('üë∂ Limpiando hijos del tema padre:', todosLosHijos.length);
    
    // Limpiar estado visual de todos los hijos
    todosLosHijos.forEach(hijo => {
      limpiarEstadoVisualDeTema(hijo.id);
    });
  }
  
  console.log('‚úÖ Estado visual del tema padre y todos sus hijos limpiado');
}

// Funci√≥n auxiliar para encontrar nodo en √°rbol completo
function encontrarNodoEnArbolCompleto(idTema, arbol) {
  for (let nodo of arbol) {
    if (nodo.id === idTema) {
      return nodo;
    }
    if (nodo.hijos && nodo.hijos.length > 0) {
      const encontrado = encontrarNodoEnArbolCompleto(idTema, nodo.hijos);
      if (encontrado) return encontrado;
    }
  }
  return null;
}

// Funci√≥n auxiliar para obtener el tema padre real (no el abuelo)
function obtenerTemaPadreReal(nodo, arbolCompleto) {
  // Buscar recursivamente el padre directo
  function buscarPadre(arbol, idBuscado) {
    for (let tema of arbol) {
      if (tema.hijos && tema.hijos.length > 0) {
        // Si es hijo directo, devolver este tema como padre
        if (tema.hijos.some(hijo => hijo.id === idBuscado)) {
          return tema;
        }
        // Buscar recursivamente en los hijos
        const padreEncontrado = buscarPadre(tema.hijos, idBuscado);
        if (padreEncontrado) return padreEncontrado;
      }
    }
    return null;
  }
  
  return buscarPadre(arbolCompleto, nodo.id);
}

// Funci√≥n auxiliar para obtener todos los hijos de un tema padre
function obtenerTodosLosHijos(temaPadre, arbolCompleto) {
  if (!temaPadre || !temaPadre.hijos) return [];
  
  const todosLosHijos = [];
  
  function recopilarHijos(nodos) {
    nodos.forEach(nodo => {
      if (nodo.esHoja) {
        todosLosHijos.push(nodo);
      }
      if (nodo.hijos && nodo.hijos.length > 0) {
        recopilarHijos(nodo.hijos);
      }
    });
  }
  
  recopilarHijos(temaPadre.hijos);
  return todosLosHijos;
}

// Cargar configuraci√≥n actual (conectado al backend)
function cargarConfiguracionActual() {
  console.log('‚öôÔ∏è Cargando configuraci√≥n actual...');
  
  if (!oposicionActiva || !oposicionActiva.id) {
    console.error('‚ùå No hay oposici√≥n activa');
    // Valores por defecto
    const elementoVuelta = document.getElementById('vueltaActual');
    const elementoMinutos = document.getElementById('minutosPorPagina');
    
    if (elementoVuelta) elementoVuelta.textContent = '1';
    if (elementoMinutos) elementoMinutos.textContent = '30';
    
    configuracionActual = {
      vueltaActual: 1,
      minPorPagV1: 30,
      minPorPagV2: 20,
      minPorPagV3: 15,
      minPorPagV4: 10
    };
    return;
  }
  
  console.log('üîç Obteniendo configuraci√≥n para oposici√≥n:', oposicionActiva.id);
  
  google.script.run
    .withSuccessHandler(function(config) {
      console.log('‚úÖ Configuraci√≥n recibida:', config);
      
      configuracionActual = config;
      
      // Actualizar interfaz
      const elementoVuelta = document.getElementById('vueltaActual');
      const elementoMinutos = document.getElementById('minutosPorPagina');
      
      if (elementoVuelta) {
        elementoVuelta.textContent = config.vueltaActual || '1';
      }
      
      if (elementoMinutos) {
        const minutosPorPagina = getMinutosPorPaginaLocal(config);
        elementoMinutos.textContent = minutosPorPagina;
      }
      
      console.log('‚úÖ Configuraci√≥n aplicada a la interfaz');
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al cargar configuraci√≥n:', error);
      
      // Valores por defecto en caso de error
      const elementoVuelta = document.getElementById('vueltaActual');
      const elementoMinutos = document.getElementById('minutosPorPagina');
      
      if (elementoVuelta) elementoVuelta.textContent = '1';
      if (elementoMinutos) elementoMinutos.textContent = '30';
      
      configuracionActual = {
        vueltaActual: 1,
        minPorPagV1: 30,
        minPorPagV2: 20,
        minPorPagV3: 15,
        minPorPagV4: 10
      };
    })
    .getConfiguracionOposicion(oposicionActiva.id);
}

// Funci√≥n auxiliar para calcular minutos por p√°gina localmente
function getMinutosPorPaginaLocal(config) {
  switch (config.vueltaActual) {
    case 1: return config.minPorPagV1;
    case 2: return config.minPorPagV2;
    case 3: return config.minPorPagV3;
    default: return config.minPorPagV4;
  }
}

function actualizarTiempoDisponible() {
  actualizarCalculoTiempo(); // Usar la nueva funci√≥n
}

// Mostrar repasos en el paso 2
function mostrarRepasosEnPasoDos() {
  console.log('üìö Mostrando repasos en paso 2...');
  
  const infoDiv = document.getElementById('infoRepasosStepDos');
  const detalleDiv = document.getElementById('detalleRepasosStepDos');
  
  // Verificar que existen los elementos
  if (!infoDiv || !detalleDiv) {
    console.error('‚ùå Elementos de repasos no encontrados en paso 2');
    return;
  }
  
  const repasos = window.repasosDelDia || [];
  console.log('üìä Repasos a mostrar:', repasos);
  
  if (repasos.length > 0) {
    const tiempoRepasos = repasos.length * 30; // 30 min por repaso
    
    let html = '<div style="display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center;">';
    html += '<div>';
    html += '<ul style="margin: 0; padding-left: 20px;">';
    
    repasos.forEach(function(repaso) {
      html += '<li><strong>R' + (repaso.numeroRepaso || '?') + ':</strong> ' + 
              (repaso.nombreTema || 'Tema desconocido') + 
              ' <span style="color: #856404;">(30 min)</span></li>';
    });
    
    html += '</ul>';
    html += '</div>';
    html += '<div style="text-align: center; background: #ffc107; color: white; padding: 10px; border-radius: 5px; min-width: 80px;">';
    html += '<div style="font-size: 20px; font-weight: bold;">' + tiempoRepasos + ' min</div>';
    html += '<div style="font-size: 12px;">Total repasos</div>';
    html += '</div>';
    html += '</div>';
    
    detalleDiv.innerHTML = html;
    infoDiv.style.display = 'block';
    
    console.log('‚úÖ Repasos mostrados en paso 2:', repasos.length, 'repasos,', tiempoRepasos, 'min');
    
  } else {
    // No hay repasos
    infoDiv.style.display = 'none';
    console.log('‚úÖ No hay repasos - ocultando secci√≥n');
  }
}

// Cargar √°rbol de temas (CORREGIDO - tiempo estudio MENOS repasos)
function cargarArbolTemas() {
  const idOposicion = document.getElementById('oposicionPlanificacion').value;
  const contenedor = document.getElementById('arbolTemas');
  
  if (!idOposicion) {
    contenedor.innerHTML = '<p style="text-align: center; color: #666;">Selecciona una oposici√≥n para cargar los temas</p>';
    return;
  }
  
  // Calcular tiempo disponible REAL (estudio - repasos)
  const horasUsuario = parseFloat(document.getElementById('horasEstudio').value) || 4;
  const tiempoEstudio = horasUsuario * 60; // Minutos de estudio
  const tiempoRepasos = window.repasosDelDia ? window.repasosDelDia.length * 30 : 0; // Minutos de repasos
  const tiempoEstudioDisponible = tiempoEstudio; // Solo tiempo para temas nuevos (sin repasos)
  
  console.log('‚è±Ô∏è Tiempo estudio:', tiempoEstudio, 'min');
  console.log('‚è±Ô∏è Tiempo repasos:', tiempoRepasos, 'min');
  console.log('‚è±Ô∏è Tiempo disponible para temas:', tiempoEstudioDisponible, 'min');
  
  // Mostrar loading
  contenedor.innerHTML = '<p style="text-align: center; color: #666;"><i class="fas fa-spinner fa-spin"></i> Cargando √°rbol de temas...</p>';
  
  google.script.run
    .withSuccessHandler(function(data) {
      console.log('‚úÖ √Årbol de temas recibido:', data);
      
      // Guardar √°rbol global para validaciones
      window.arbolCompletoGlobal = data.arbol;
      
      if (!data || !data.arbol || data.arbol.length === 0) {
        contenedor.innerHTML = '<p style="text-align: center; color: #999;">No hay temas principales vinculados a esta oposici√≥n</p>';
        return;
      }
      
      // Renderizar √°rbol real
      renderizarArbolPorBloques(data.arbol, data.minutosPorPagina, data.bloques);
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al cargar √°rbol:', error);
      contenedor.innerHTML = '<p style="color: red; text-align: center;">Error al cargar temas: ' + error.message + '</p>';
    })
    .getArbolTemasConEstados(idOposicion, tiempoEstudioDisponible); // ‚Üê TIEMPO SIN REPASOS
}

// Renderizar √°rbol agrupado por bloques (CORREGIDO)
function renderizarArbolPorBloques(arbolTemas, minutosPorPagina, bloquesInfo) {
  const contenedor = document.getElementById('arbolTemas');
  
  if (!arbolTemas || arbolTemas.length === 0) {
    contenedor.innerHTML = '<p style="text-align: center; color: #666;">No hay temas vinculados a esta oposici√≥n</p>';
    return;
  }
  
  // Agrupar temas por bloque (USANDO DATOS REALES)
  const temasPorBloque = agruparTemasPorBloque(arbolTemas, bloquesInfo);
  
  let html = '';
  
  // Renderizar cada bloque
  Object.keys(temasPorBloque).forEach(nombreBloque => {
    const temasDelBloque = temasPorBloque[nombreBloque];
    const esEspecial = esBloqueBloqueEspecial(nombreBloque);
    
    html += '<div style="margin-bottom: 20px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden;">';
    
    // Header del bloque (colapsable)
    html += '<div onclick="toggleBloque(\'' + nombreBloque + '\')" style="padding: 15px; background: #f8f9fa; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee;">';
    html += '<div>';
    html += '<h6 style="margin: 0; font-weight: bold;">' + nombreBloque;
    if (esEspecial) {
      html += ' <span style="background: #ffc107; color: #212529; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin-left: 8px;">ESPECIAL</span>';
    }
    html += '</h6>';
    html += '<small style="color: #666;">' + temasDelBloque.length + ' temas principales</small>';
    html += '</div>';
    html += '<i id="icono-' + nombreBloque + '" style="transition: transform 0.3s;">‚ñº</i>';
    html += '</div>';
    
    // Contenido del bloque (inicialmente visible)
    html += '<div id="bloque-' + nombreBloque + '" style="padding: 15px;">';
    
    // Renderizar cada tema del bloque
    temasDelBloque.forEach(tema => {
      html += renderizarNodoTemaConPreseleccion(tema, 0, nombreBloque);
    });
    
    html += '</div>';
    html += '</div>';
  });
  
  contenedor.innerHTML = html;
}

// Agrupar temas por bloque (USANDO DATOS REALES)
function agruparTemasPorBloque(arbolTemas, bloquesInfo) {
  const temasPorBloque = {};
  
  arbolTemas.forEach(tema => {
    const idBloque = tema.idBloque;
    const nombreBloque = bloquesInfo[idBloque] || 'Sin Bloque';
    
    if (!temasPorBloque[nombreBloque]) {
      temasPorBloque[nombreBloque] = [];
    }
    
    temasPorBloque[nombreBloque].push(tema);
  });
  
  console.log('üìä Temas agrupados por bloque:', temasPorBloque);
  return temasPorBloque;
}

// Renderizar nodo de tema con checkbox padre/hijo
function renderizarNodoTema(nodo, nivel, nombreBloque) {
  const margenIzquierdo = nivel * 20;
  const iconoEstado = getIconoEstado(nodo.estado);
  const colorFondo = getColorFondo(nodo.estado);
  
  let html = '';
  
  // Contenedor del nodo
  html += '<div style="margin-left: ' + margenIzquierdo + 'px; margin-bottom: 8px;">';
  
  // Fila del tema
  html += '<div style="display: flex; align-items: center; padding: 10px; background: ' + colorFondo + '; border: 1px solid #e0e0e0; border-radius: 6px;">';
  
  // Checkbox (para hojas seleccionables O padres seleccionables)
  if (nodo.seleccionable || nodo.seleccionablePadre) {
    const yaSeleccionado = temasSeleccionados.some(t => t.id === nodo.id);
    const tipoSeleccion = nodo.seleccionablePadre ? 'padre' : 'hijo';
    
    html += '<input type="checkbox" ';
    html += 'onchange="toggleSeleccionTemaConValidacion(this, ' + nodo.id + ', ' + nodo.tiempoMinutos + ', \'' + nombreBloque + '\', \'' + tipoSeleccion + '\')" ';
    html += (yaSeleccionado ? 'checked ' : '');
    html += 'style="margin-right: 10px; transform: scale(1.2);" ';
    html += 'title="' + (nodo.seleccionablePadre ? 'Seleccionar tema completo (' + nodo.tiempoTexto + ')' : 'Seleccionar subtema') + '">';
  } else {
    html += '<span style="width: 24px; margin-right: 10px; text-align: center; font-size: 16px;">' + iconoEstado + '</span>';
  }
  
  // Contenido del tema
  html += '<div style="flex: 1;">';
  html += '<div style="font-weight: ' + (nivel === 0 ? 'bold' : 'normal') + '; color: ' + getColorTexto(nodo.estado) + ';">';
  html += nodo.nombreCompleto;
  html += '</div>';
  
  if (nodo.paginas > 0) {
    html += '<small style="color: #666; font-size: 11px;">';
    html += nodo.paginas + ' p√°gs ‚Ä¢ ' + nodo.tiempoTexto;
    html += '</small>';
  }
  html += '</div>';
  
  // Badge de estado
  html += '<div style="margin-left: 10px;">';
  html += '<span style="font-size: 10px; padding: 3px 8px; border-radius: 12px; background: ' + getColorBadge(nodo.estado) + '; color: white; font-weight: bold;">';
  html += getTextoEstado(nodo.estado);
  html += '</span>';
  html += '</div>';
  
  html += '</div>';
  
  // Renderizar hijos si existen
  if (nodo.hijos && nodo.hijos.length > 0) {
    nodo.hijos.forEach(hijo => {
      html += renderizarNodoTema(hijo, nivel + 1, nombreBloque);
    });
  }
  
  html += '</div>';
  
  return html;
}

// CORRECCI√ìN 38: En scriptsPlanificacion.html
// Reemplazar la funci√≥n validarSeleccionTemaConReglasPadre() existente

function validarSeleccionTemaConReglasPadre(idTema, nombreBloque) {
  console.log('üîç Validando tema padre original por bloque:', idTema, 'en bloque:', nombreBloque);
  
  // Encontrar el nodo del tema seleccionado
  const nodoTema = encontrarNodoEnArbolCompleto(idTema, window.arbolCompletoGlobal);
  if (!nodoTema) {
    return { valido: true };
  }
  
  // Obtener el tema padre original del tema seleccionado
  const temaPadreOriginalNuevo = obtenerTemaPadreOriginal(nodoTema, window.arbolCompletoGlobal);
  console.log('üë®‚Äçüëß‚Äçüë¶ Tema padre original del nuevo tema:', temaPadreOriginalNuevo.nombreCompleto);
  
  // Si no hay temas seleccionados, permitir libre elecci√≥n
  if (temasSeleccionados.length === 0) {
    console.log('‚úÖ Primer tema - libre elecci√≥n');
    return { valido: true };
  }
  
  // Obtener temas del MISMO BLOQUE
  const temasDelMismoBloque = temasSeleccionados.filter(t => t.bloque === nombreBloque);
  
  // Si no hay temas del mismo bloque, permitir (es de bloque diferente)
  if (temasDelMismoBloque.length === 0) {
    console.log('‚úÖ Bloque diferente - libre elecci√≥n');
    return { valido: true };
  }
  
  // REGLA CLAVE: Obtener el tema padre original YA ESTABLECIDO para este bloque
  let temaPadreOriginalDelBloque = null;
  
  for (const temaDelBloque of temasDelMismoBloque) {
    const nodoExistente = encontrarNodoEnArbolCompleto(temaDelBloque.id, window.arbolCompletoGlobal);
    if (nodoExistente) {
      const temaPadreOriginalExistente = obtenerTemaPadreOriginal(nodoExistente, window.arbolCompletoGlobal);
      
      if (!temaPadreOriginalDelBloque) {
        temaPadreOriginalDelBloque = temaPadreOriginalExistente;
      } else if (temaPadreOriginalDelBloque.id !== temaPadreOriginalExistente.id) {
        // ¬°PROBLEMA! Ya hay temas de diferentes temas padre originales en el mismo bloque
        console.error('‚ùå INCONSISTENCIA: Diferentes temas padre originales en el mismo bloque');
      }
    }
  }
  
  console.log('üìã Tema padre original establecido para bloque "' + nombreBloque + '":', 
             temaPadreOriginalDelBloque ? temaPadreOriginalDelBloque.nombreCompleto : 'Ninguno');
  
  // VALIDACI√ìN: El nuevo tema debe pertenecer al mismo tema padre original del bloque
  if (temaPadreOriginalDelBloque && temaPadreOriginalNuevo.id !== temaPadreOriginalDelBloque.id) {
    const mensaje = 'Un tema padre original por bloque üì¶\n\n' +
                   'Bloque: "' + nombreBloque + '"\n' +
                   'Tema padre original establecido: "' + temaPadreOriginalDelBloque.nombreCompleto + '"\n' +
                   'Tema padre original del nuevo tema: "' + temaPadreOriginalNuevo.nombreCompleto + '"\n\n' +
                   'Solo puedes tener temas de UN tema padre original por bloque.\n' +
                   'Esto mantiene la coherencia y el orden del estudio.\n\n' +
                   '¬øQuieres seleccionar el tema de todas formas?';
    
    // Usar sistema de advertencias de dos niveles
    const claveAdvertencia = `tema_padre_bloque_${nombreBloque}_${temaPadreOriginalDelBloque.id}_vs_${temaPadreOriginalNuevo.id}`;
    const permitido = manejarAdvertenciaConDobleNivel('bloques', claveAdvertencia, mensaje, idTema);
    
    return {
      valido: permitido,
      mensaje: permitido ? '' : 'Advertencia de tema padre por bloque mostrada',
      requiereAdvertencia: true
    };
  }
  
  console.log('‚úÖ Tema padre original v√°lido para el bloque');
  return { valido: true };
}


// Toggle selecci√≥n con validaci√≥n de orden (FUNCI√ìN COMPLETA)
// CORRECCI√ìN 42: En scriptsPlanificacion.html
// Reemplazar la funci√≥n toggleSeleccionTemaConValidacion() existente

function toggleSeleccionTemaConValidacion(checkbox, idTema, tiempoMinutos, nombreBloque, tipoSeleccion) {
  console.log('üéØ Toggle selecci√≥n tema:', idTema, tiempoMinutos + 'min', nombreBloque, tipoSeleccion);
  
  if (checkbox.checked) {
    // ===== VALIDACIONES PARA SELECCI√ìN =====
    
    // VALIDACI√ìN 1: L√≠mites de tiempo (restrictiva - no se puede sobrepasar)
    const validacionLimites = validarSeleccionTema(tiempoMinutos, nombreBloque);
    if (!validacionLimites.valido) {
      checkbox.checked = false;
      alert('‚ö†Ô∏è ' + validacionLimites.mensaje);
      return;
    }
    
    // VALIDACI√ìN 2: Un tema padre original por bloque (con advertencias de dos niveles)
    const validacionTemaPadre = validarSeleccionTemaConReglasPadre(idTema, nombreBloque);
    if (!validacionTemaPadre.valido) {
      checkbox.checked = false;
      return; // Ya manejado con sistema de advertencias
    }
    
    // VALIDACI√ìN 3: Orden dentro del tema padre original (con advertencias de dos niveles)
    const nodoSeleccionado = { id: idTema };
    const validacionOrden = validarOrdenConsecutivo(nodoSeleccionado, window.arbolCompletoGlobal);
    
    if (!validacionOrden.esConsecutivo && validacionOrden.requiereAdvertencia) {
      const claveAdvertencia = `orden_tema_padre_${validacionOrden.temaPadreOriginal}_tema_${idTema}`;
      const permitidoPorOrden = manejarAdvertenciaConDobleNivel('orden', claveAdvertencia, validacionOrden.mensaje, idTema);
      
      if (!permitidoPorOrden) {
        checkbox.checked = false;
        return; // Primera advertencia - no permitir
      }
      // Segunda advertencia o m√°s - continuar con la selecci√≥n
    }
    
    // ‚úÖ TODAS LAS VALIDACIONES PASADAS - Proceder con la selecci√≥n
    console.log('‚úÖ Todas las validaciones pasadas - a√±adiendo tema');
    
    // Agregar tema a la lista
    temasSeleccionados.push({
      id: idTema,
      tiempo: tiempoMinutos,
      bloque: nombreBloque,
      tipo: tipoSeleccion
    });
    
    // A√±adir bloque a la lista si no est√°
    if (!bloquesActivos.includes(nombreBloque)) {
      bloquesActivos.push(nombreBloque);
    }
    
    // Actualizar tiempo usado
    tiempoUsado += tiempoMinutos;
    
    console.log('‚úÖ Tema a√±adido:', {
      id: idTema,
      tiempo: tiempoMinutos,
      bloque: nombreBloque,
      tipo: tipoSeleccion,
      tiempoTotalUsado: tiempoUsado
    });
    
    // üîÑ Si es tema padre, seleccionar hijos autom√°ticamente
    if (tipoSeleccion === 'padre') {
      const hijosAutomaticos = seleccionarHijosAutomaticamente(idTema, nombreBloque);
      
      // A√±adir hijos autom√°ticos a la lista (con tiempo 0)
      hijosAutomaticos.forEach(hijo => {
        temasSeleccionados.push(hijo);
      });
      
      // Expandir autom√°ticamente el tema padre para mostrar los hijos
      setTimeout(() => {
        expandirCaminoHaciaTema(idTema);
        
        alert('‚úÖ Tema padre seleccionado: ' + formatearTiempo(tiempoMinutos) + '\n\n' +
              'üîÑ Se han seleccionado autom√°ticamente ' + hijosAutomaticos.length + ' subtemas.\n' +
              '‚è±Ô∏è Tiempo total: Solo cuenta el del tema padre.\n' +
              'üëÅÔ∏è Los subtemas se muestran expandidos con badge "AUTO".');
      }, 100);
      
      console.log('üîÑ Hijos autom√°ticos a√±adidos:', hijosAutomaticos.length);
    }
    
  } else {
    // ===== DESELECCI√ìN =====
    console.log('‚ùå Iniciando deselecci√≥n del tema:', idTema);
    
    // Buscar el tema en la lista
    const index = temasSeleccionados.findIndex(t => t.id === idTema);
    if (index > -1) {
      const tema = temasSeleccionados[index];
      
      // Remover de la lista
      temasSeleccionados.splice(index, 1);
      tiempoUsado -= tema.tiempo;
      
      console.log('‚è±Ô∏è Tiempo restado:', tema.tiempo, 'min. Nuevo total:', tiempoUsado, 'min');
      
      // Si era tema padre, limpiar hijos autom√°ticos
      if (tema.tipo === 'padre') {
        console.log('üë®‚Äçüëß‚Äçüë¶ Era tema padre - limpiando hijos autom√°ticos');
        desmarcarHijosAutomaticos(idTema);
        limpiarEstadoVisualTemaPadre(idTema);
      } else {
        // Para temas normales, limpiar solo su estado visual
        limpiarEstadoVisualDeTema(idTema);
      }
      
      // Verificar si quitar bloque de la lista activa
      const masDelMismoBloque = temasSeleccionados.some(t => t.bloque === nombreBloque);
      if (!masDelMismoBloque) {
        const indexBloque = bloquesActivos.indexOf(nombreBloque);
        if (indexBloque > -1) {
          bloquesActivos.splice(indexBloque, 1);
          console.log('üì¶ Bloque removido de activos:', nombreBloque);
        }
      }
      
      console.log('‚úÖ Tema removido completamente');
      
    } else {
      console.warn('‚ö†Ô∏è Tema no encontrado en lista para deseleccionar:', idTema);
      limpiarEstadoVisualDeTema(idTema); // Limpiar por si acaso
    }
  }
  
  // Actualizar resumen y verificar estado
  actualizarResumenTiempo();
  
  // Log del estado final
  console.log('üìä Estado final del toggle:');
  console.log('   - Temas seleccionados:', temasSeleccionados.length);
  console.log('   - Tiempo total usado:', tiempoUsado, 'min');
  console.log('   - Bloques activos:', bloquesActivos);
}

// Formatear tiempo localmente
function formatearTiempo(minutos) {
  if (!minutos || minutos <= 0) return '0m';
  
  const horas = Math.floor(minutos / 60);
  const mins = minutos % 60;
  
  if (horas > 0) {
    return horas + 'h ' + mins + 'm';
  } else {
    return mins + 'm';
  }
}

// Funciones auxiliares para estilos
function getIconoEstado(estado) {
  switch (estado) {
    case 'completado': return '‚úÖ';
    case 'en_progreso': return 'üîÑ';
    default: return '‚≠ï';
  }
}

function getColorFondo(estado) {
  switch (estado) {
    case 'completado': return '#e8f5e9';
    case 'en_progreso': return '#fff3e0';
    default: return '#ffffff';
  }
}

function getColorTexto(estado) {
  switch (estado) {
    case 'completado': return '#2e7d32';
    case 'en_progreso': return '#ef6c00';
    default: return '#333333';
  }
}

function getColorBadge(estado) {
  switch (estado) {
    case 'completado': return '#4caf50';
    case 'en_progreso': return '#ff9800';
    default: return '#9e9e9e';
  }
}

function getTextoEstado(estado) {
  switch (estado) {
    case 'completado': return 'OK';
    case 'en_progreso': return 'PROG';
    default: return 'PEND';
  }
}

// Verificar si es bloque especial
function esBloqueBloqueEspecial(nombreBloque) {
  const nombre = nombreBloque.toLowerCase();
  return nombre.includes('geograf√≠a') || nombre.includes('geografia') || nombre.includes('callejero');
}

// Toggle colapsar bloque
function toggleBloque(nombreBloque) {
  const contenido = document.getElementById('bloque-' + nombreBloque);
  const icono = document.getElementById('icono-' + nombreBloque);
  
  if (contenido.style.display === 'none') {
    contenido.style.display = 'block';
    icono.textContent = '‚ñº';
  } else {
    contenido.style.display = 'none';
    icono.textContent = '‚ñ∂';
  }
}

// Toggle selecci√≥n de tema
function toggleSeleccionTema(checkbox, idTema, tiempoMinutos, nombreBloque) {
  if (checkbox.checked) {
    // Validar selecci√≥n
    const validacion = validarSeleccionTema(tiempoMinutos, nombreBloque);
    if (!validacion.valido) {
      checkbox.checked = false;
      alert('‚ö†Ô∏è ' + validacion.mensaje);
      return;
    }
    
    // Agregar tema
    temasSeleccionados.push({
      id: idTema,
      tiempo: tiempoMinutos,
      bloque: nombreBloque
    });
    
    if (!bloquesActivos.includes(nombreBloque)) {
      bloquesActivos.push(nombreBloque);
    }
    
    tiempoUsado += tiempoMinutos;
    
  } else {
    // Quitar tema
    const index = temasSeleccionados.findIndex(t => t.id === idTema);
    if (index > -1) {
      const tema = temasSeleccionados[index];
      temasSeleccionados.splice(index, 1);
      tiempoUsado -= tema.tiempo;
      
      // Verificar si quitar bloque
      const masDelMismoBloque = temasSeleccionados.some(t => t.bloque === nombreBloque);
      if (!masDelMismoBloque) {
        const indexBloque = bloquesActivos.indexOf(nombreBloque);
        if (indexBloque > -1) {
          bloquesActivos.splice(indexBloque, 1);
        }
      }
    }
  }
  
  actualizarResumenTiempo();
}

// Validar selecci√≥n de tema
// CORRECCI√ìN 23: En scriptsPlanificacion.html
// Reemplazar la funci√≥n validarSeleccionTema() existente

function validarSeleccionTema(tiempoMinutos, nombreBloque) {
  console.log('‚è±Ô∏è Validando l√≠mites para:', tiempoMinutos, 'min en bloque', nombreBloque);
  console.log('üìä Tiempo actual usado:', tiempoUsado, '/ Disponible:', tiempoTotalDisponible);
  
  // VALIDACI√ìN 1: Verificar tiempo disponible (esta sigue siendo restrictiva por seguridad)
  if (tiempoUsado + tiempoMinutos > tiempoTotalDisponible) {
    const exceso = (tiempoUsado + tiempoMinutos - tiempoTotalDisponible);
    return {
      valido: false,
      mensaje: 'Excede el tiempo disponible üïí\n\n' +
               'Tiempo disponible: ' + formatearTiempo(tiempoTotalDisponible) + '\n' +
               'Ya usado: ' + formatearTiempo(tiempoUsado) + '\n' +
               'Este tema: ' + formatearTiempo(tiempoMinutos) + '\n' +
               'Exceso: ' + formatearTiempo(exceso) + '\n\n' +
               'üí° Soluciones:\n' +
               '‚Ä¢ Aumenta las horas de estudio en el Paso 2\n' +
               '‚Ä¢ Selecciona menos temas o m√°s cortos\n' +
               '‚Ä¢ Revisa si hay repasos que reduzcan el tiempo'
    };
  }
  
  // VALIDACI√ìN 2: Verificar l√≠mite de bloques (ahora informativa con sistema de advertencias)
  if (!bloquesActivos.includes(nombreBloque)) {
    const esEspecial = esBloqueBloqueEspecial(nombreBloque);
    const bloquesNormales = bloquesActivos.filter(b => !esBloqueBloqueEspecial(b));
    const bloquesEspeciales = bloquesActivos.filter(b => esBloqueBloqueEspecial(b));
    
    console.log('üìä Bloques actuales:', {
      normales: bloquesNormales,
      especiales: bloquesEspeciales,
      nuevoEsEspecial: esEspecial
    });
    
    // L√≠mites con advertencias informativas
    let mensajeAdvertencia = '';
    let claveAdvertencia = '';
    let debeAdvertir = false;
    
    if (!esEspecial && bloquesNormales.length >= 4) {
      mensajeAdvertencia = 'M√°ximo de bloques normales recomendado üìö\n\n' +
                          'Ya tienes ' + bloquesNormales.length + ' bloques normales:\n' +
                          bloquesNormales.join(', ') + '\n\n' +
                          'Nuevo bloque: ' + nombreBloque + '\n\n' +
                          'Muchos bloques pueden dispersar la concentraci√≥n.\n' +
                          'Se recomienda m√°ximo 4 bloques normales por sesi√≥n.';
      claveAdvertencia = `bloques_normales_${bloquesNormales.length + 1}`;
      debeAdvertir = true;
      
    } else if (esEspecial && bloquesEspeciales.length >= 2) {
      mensajeAdvertencia = 'M√°ximo de bloques especiales recomendado üéØ\n\n' +
                          'Ya tienes ' + bloquesEspeciales.length + ' bloques especiales:\n' +
                          bloquesEspeciales.join(', ') + '\n\n' +
                          'Nuevo bloque: ' + nombreBloque + '\n\n' +
                          'Los bloques especiales (Geograf√≠a/Callejero) requieren\n' +
                          'concentraci√≥n espec√≠fica. M√°ximo 2 recomendados.';
      claveAdvertencia = `bloques_especiales_${bloquesEspeciales.length + 1}`;
      debeAdvertir = true;
      
    } else if (bloquesActivos.length >= 5) {
      mensajeAdvertencia = 'Muchos bloques en una sesi√≥n üß†\n\n' +
                          'Ya tienes ' + bloquesActivos.length + ' bloques activos:\n' +
                          bloquesActivos.join(', ') + '\n\n' +
                          'Nuevo bloque: ' + nombreBloque + '\n\n' +
                          'Cambiar entre muchos bloques puede reducir la eficiencia.\n' +
                          'Se recomienda concentrarse en menos bloques por sesi√≥n.';
      claveAdvertencia = `bloques_totales_${bloquesActivos.length + 1}`;
      debeAdvertir = true;
    }
    
    if (debeAdvertir) {
      // Usar sistema de advertencias de dos niveles para bloques
      const permitido = manejarAdvertenciaConDobleNivel('bloques', claveAdvertencia, mensajeAdvertencia);
      
      if (!permitido) {
        return {
          valido: false,
          mensaje: 'Advertencia de bloques mostrada'
        };
      }
      // Si permitido = true, continuar con la selecci√≥n
    }
  }
  
  console.log('‚úÖ Validaciones de l√≠mites pasadas');
  return { valido: true };
}

// Actualizar resumen de tiempo
// CORRECCI√ìN 36: En scriptsPlanificacion.html
// Reemplazar la funci√≥n actualizarResumenTiempo() existente

function actualizarResumenTiempo() {
  console.log('üìä Actualizando resumen de tiempo...');
  console.log('   - Tiempo total disponible:', tiempoTotalDisponible);
  console.log('   - Tiempo usado:', tiempoUsado);
  console.log('   - Bloques activos:', bloquesActivos);
  
  const tiempoRestante = tiempoTotalDisponible - tiempoUsado;
  
  // Actualizar elementos de la interfaz si existen
  const elementoTiempoTotal = document.getElementById('tiempoTotal');
  const elementoTiempoSeleccionado = document.getElementById('tiempoSeleccionado');
  const elementoTiempoRestante = document.getElementById('tiempoRestante');
  const elementoBloquesUsados = document.getElementById('bloquesUsados');
  
  if (elementoTiempoTotal) elementoTiempoTotal.textContent = tiempoTotalDisponible;
  if (elementoTiempoSeleccionado) elementoTiempoSeleccionado.textContent = tiempoUsado;
  if (elementoTiempoRestante) elementoTiempoRestante.textContent = tiempoRestante;
  if (elementoBloquesUsados) elementoBloquesUsados.textContent = bloquesActivos.length + '/4+';
  
  // Cambiar colores seg√∫n estado
  if (elementoTiempoRestante) {
    if (tiempoRestante < 0) {
      elementoTiempoRestante.style.color = '#dc3545';
    } else if (tiempoRestante < 30) {
      elementoTiempoRestante.style.color = '#ffc107';
    } else {
      elementoTiempoRestante.style.color = '#28a745';
    }
  }
  
  // üîÑ NUEVA: Verificaci√≥n autom√°tica del estado
  verificarEstadoAutomaticamente();
  
  // Actualizar estado visual del √°rbol
  setTimeout(() => {
    actualizarEstadoVisualDelArbol();
  }, 100);
  
  console.log('‚úÖ Resumen actualizado - Restante:', tiempoRestante, 'min');
}

// Crear planificaci√≥n
// 8. FUNCI√ìN PRINCIPAL: Crear planificaci√≥n (REEMPLAZAR LA EXISTENTE)
function crearPlanificacion() {
  console.log('üìù Iniciando creaci√≥n de planificaci√≥n...');
  
  // Validaciones finales
  const validacion = validarAntesDeCrear();
  if (!validacion.valido) {
    alert('‚ö†Ô∏è ' + validacion.mensaje);
    return;
  }
  
  // Recopilar datos
  const datosplanificacion = recopilarDatosPlanificacion();
  console.log('üìä Datos recopilados:', datosplanificacion);
  
  // Mostrar confirmaci√≥n
  const confirmacion = mostrarConfirmacionCreacion(datosplanificacion);
  if (!confirmacion) {
    return;
  }
  
  // Deshabilitar bot√≥n y mostrar loading
  const btnCrear = document.getElementById('btnSiguiente');
  btnCrear.disabled = true;
  btnCrear.textContent = '‚è≥ Creando planificaci√≥n...';
  
  // Llamar al backend
  google.script.run
    .withSuccessHandler(function(resultado) {
      console.log('‚úÖ Planificaci√≥n creada:', resultado);
      mostrarExitoCreacion(resultado);
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al crear planificaci√≥n:', error);
      mostrarErrorCreacion(error);
    })
    .crearPlanificacionCompleta(datosplanificacion);
}


// 9. Validaciones finales antes de crear
function validarAntesDeCrear() {
  console.log('üîç Validando antes de crear planificaci√≥n...');
  
  // Validar que hay temas seleccionados
  if (temasSeleccionados.length === 0) {
    return {
      valido: false,
      mensaje: 'Debes seleccionar al menos un tema para estudiar.\n\nVuelve al paso anterior y selecciona algunos temas.'
    };
  }
  
  // Validar fecha
  const fechaInput = document.getElementById('fechaPlanificacion');
  if (!fechaInput || !fechaInput.value) {
    return {
      valido: false,
      mensaje: 'Fecha no v√°lida.\n\nVuelve al paso 1 y selecciona una fecha.'
    };
  }
  
  // Validar oposici√≥n activa
  if (!oposicionActiva || !oposicionActiva.id) {
    return {
      valido: false,
      mensaje: 'No hay oposici√≥n activa.\n\nConfigura una oposici√≥n activa antes de crear planificaciones.'
    };
  }
  
  // Validar tiempo disponible
  if (tiempoTotalDisponible <= 0) {
    return {
      valido: false,
      mensaje: 'No hay tiempo disponible para estudiar.\n\nRevisa las horas previstas y los repasos del d√≠a.'
    };
  }
  
  console.log('‚úÖ Validaciones pasadas');
  return { valido: true };
}


// 10. Recopilar datos de la planificaci√≥n
function recopilarDatosPlanificacion() {
  const fechaInput = document.getElementById('fechaPlanificacion');
  const horasInput = document.getElementById('horasEstudio');
  
  const tiempoPrevisto = parseFloat(horasInput.value) * 60; // en minutos
  const tiempoRepasos = window.tiempoRepasosDelDia || 0;
  const tiempoEstudio = window.tiempoRealParaTemas || (tiempoPrevisto - tiempoRepasos);
  
  // Contar bloques √∫nicos
  const bloquesUnicos = [...new Set(temasSeleccionados.map(t => t.bloque))];
  
  return {
    fecha: fechaInput.value,
    idOposicion: oposicionActiva.id,
    tiempoPrevisto: tiempoPrevisto,
    tiempoRepasos: tiempoRepasos,
    tiempoEstudio: tiempoEstudio,
    temasSeleccionados: temasSeleccionados,
    numeroBloqures: bloquesUnicos.length
  };
}

// 11. Mostrar confirmaci√≥n antes de crear
function mostrarConfirmacionCreacion(datos) {
  const temasPrincipales = datos.temasSeleccionados.filter(t => t.tipo !== 'hijo_automatico');
  const hijosAutomaticos = datos.temasSeleccionados.filter(t => t.tipo === 'hijo_automatico');
  
  let mensaje = 'üìù Confirmar creaci√≥n de planificaci√≥n\n\n';
  mensaje += `üìÖ Fecha: ${datos.fecha}\n`;
  mensaje += `üìö Oposici√≥n: ${oposicionActiva.nombre}\n\n`;
  mensaje += `‚è±Ô∏è Tiempo previsto: ${Math.round(datos.tiempoPrevisto / 60 * 10) / 10}h\n`;
  mensaje += `üìñ Tiempo para estudio: ${Math.round(datos.tiempoEstudio / 60 * 10) / 10}h\n`;
  if (datos.tiempoRepasos > 0) {
    mensaje += `üîÑ Tiempo repasos: ${Math.round(datos.tiempoRepasos / 60 * 10) / 10}h\n`;
  }
  mensaje += `\nüìã Temas principales: ${temasPrincipales.length}\n`;
  if (hijosAutomaticos.length > 0) {
    mensaje += `üë∂ Subtemas autom√°ticos: ${hijosAutomaticos.length}\n`;
  }
  mensaje += `üì¶ Bloques: ${datos.numeroBloqures}\n\n`;
  mensaje += `üìù Esta planificaci√≥n guardar√° tu intenci√≥n de estudio.\n`;
  mensaje += `üîÑ Los repasos se crear√°n autom√°ticamente cuando\n`;
  mensaje += `    marques los temas como completados.\n\n`;
  mensaje += `¬øConfirmas la creaci√≥n de esta planificaci√≥n?`;
  
  return confirm(mensaje);
}

// 12. Mostrar √©xito despu√©s de crear
function mostrarExitoCreacion(resultado) {
  // Restaurar bot√≥n
  const btnCrear = document.getElementById('btnSiguiente');
  btnCrear.disabled = false;
  btnCrear.textContent = 'Crear Planificaci√≥n';
  
  // Mostrar mensaje de √©xito
  alert('üéâ ¬°Planificaci√≥n creada correctamente!\n\n' +
        `üìù ID: ${resultado.idPlanificacion}\n` +
        `üìö Temas planificados: ${resultado.temasCreados}\n\n` +
        '‚úÖ La planificaci√≥n se ha guardado correctamente.\n\n' +
        'üîÑ Los repasos se crear√°n autom√°ticamente cuando\n' +
        '   marques los temas como completados durante el estudio.');
  
  // Cerrar modal y actualizar calendario
  cerrarModal();
  
  // Actualizar calendario si es necesario
  if (typeof renderizarCalendario === 'function') {
    renderizarCalendario();
  }
}

// 13. Mostrar error si falla la creaci√≥n
function mostrarErrorCreacion(error) {
  // Restaurar bot√≥n
  const btnCrear = document.getElementById('btnSiguiente');
  btnCrear.disabled = false;
  btnCrear.textContent = 'Crear Planificaci√≥n';
  
  // Mostrar error
  alert('‚ùå Error al crear la planificaci√≥n\n\n' +
        'Detalles: ' + error.message + '\n\n' +
        'Revisa los datos e int√©ntalo de nuevo.\n' +
        'Si el problema persiste, contacta al administrador.');
}

// üìÖ FUNCI√ìN 1: Cargar planificaciones en el calendario
function cargarPlanificacionesEnCalendario() {
  const a√±o = mesActual.getFullYear();
  const mes = mesActual.getMonth();
  
  console.log('üìÖ Cargando planificaciones para:', a√±o, mes + 1);
  
  google.script.run
    .withSuccessHandler(function(planificaciones) {
      console.log('‚úÖ Planificaciones recibidas:', planificaciones.length);
      mostrarPlanificacionesEnCalendario(planificaciones);
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al cargar planificaciones:', error);
    })
    .getPlanificacionesDelMes(a√±o, mes);
}


// üìÖ FUNCI√ìN 2: Mostrar planificaciones en los d√≠as del calendario
function mostrarPlanificacionesEnCalendario(planificaciones) {
  planificaciones.forEach(plan => {
    const fecha = new Date(plan.fecha);
    const dia = fecha.getDate();
    const contenedorDia = document.getElementById(`contenido-${fecha.getFullYear()}-${fecha.getMonth()}-${dia}`);
    
    if (contenedorDia) {
      let html = '';
      
      // Color seg√∫n estado
      let colorFondo = '#e3f2fd'; // azul por defecto
      let icono = 'üìö';
      
      if (plan.estado === 'completado') {
        colorFondo = '#e8f5e9';
        icono = '‚úÖ';
      } else if (plan.estado === 'en_progreso') {
        colorFondo = '#fff3e0';
        icono = 'üîÑ';
      }
      
      html += `<div style="background: ${colorFondo}; padding: 3px; border-radius: 3px; margin: 1px 0; font-size: 10px; cursor: pointer;" `;
      html += `onclick="mostrarDetallePlanificacion('${plan.id}')" title="Ver detalle de planificaci√≥n">`;
      html += `${icono} ${plan.numeroTemas} temas`;
      html += `<br><small style="font-size: 8px;">${Math.round(plan.tiempoEstudio / 60)}h</small>`;
      html += '</div>';
      
      contenedorDia.innerHTML = html;
    }
  });
}

// üìÖ FUNCI√ìN 3: Mostrar detalle de planificaci√≥n espec√≠fica
function mostrarDetallePlanificacion(idPlanificacion) {
  console.log('üìù Mostrando detalle de planificaci√≥n:', idPlanificacion);
  
  // Mostrar loading en el detalle del d√≠a
  document.getElementById('contenidoDetalleDia').innerHTML = 
    '<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> Cargando detalle...</div>';
  
  google.script.run
    .withSuccessHandler(function(detalle) {
      if (detalle) {
        renderizarDetallePlanificacion(detalle);
      } else {
        document.getElementById('contenidoDetalleDia').innerHTML = 
          '<div style="color: red; text-align: center; padding: 20px;">‚ùå Planificaci√≥n no encontrada</div>';
      }
    })
    .withFailureHandler(function(error) {
      console.error('‚ùå Error al cargar detalle:', error);
      document.getElementById('contenidoDetalleDia').innerHTML = 
        '<div style="color: red; text-align: center; padding: 20px;">‚ùå Error: ' + error.message + '</div>';
    })
    .getDetallePlanificacion(idPlanificacion);
}

// Ejemplo de uso en el calendario (modificar funci√≥n seleccionarDia)
function seleccionarDiaConPlanificacion(dia) {
  // ... c√≥digo existente de seleccionarDia ...
  
  // Cargar detalle de planificaci√≥n para este d√≠a
  mostrarDetalleDiaSeleccionado(dia);
}

// üìÖ FUNCI√ìN 4: Renderizar detalle completo de planificaci√≥n
function renderizarDetallePlanificacion(detalle) {
  console.log('üé® Renderizando detalle:', detalle);
  
  const contenedor = document.getElementById('contenidoDetalleDia');
  
  // Calcular estad√≠sticas
  const temasCompletados = detalle.temas.filter(t => t.estado === 'completado').length;
  const temasEnProgreso = detalle.temas.filter(t => t.estado === 'en_progreso').length;
  const temasPendientes = detalle.temas.filter(t => t.estado === 'planificado').length;
  
  const tiempoTotalAsignado = detalle.temas.reduce((total, tema) => total + (tema.tiempoAsignado || 0), 0);
  const tiempoTotalDedicado = detalle.temas.reduce((total, tema) => total + (tema.tiempoDedicado || 0), 0);
  
  let html = '';
  
  // Header con informaci√≥n general
  html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #007bff;">';
  html += '<h4 style="margin: 0 0 10px 0; color: #007bff;">üìù Detalle de Planificaci√≥n</h4>';
  
  // Info b√°sica
  html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">';
  html += '<div><strong>üìÖ Fecha:</strong> ' + new Date(detalle.fecha).toLocaleDateString('es-ES') + '</div>';
  html += '<div><strong>üìö Oposici√≥n:</strong> ' + (detalle.nombreOposicion || 'No disponible') + '</div>';
  html += '<div><strong>‚è±Ô∏è Tiempo previsto:</strong> ' + Math.round(detalle.tiempoPrevisto / 60 * 10) / 10 + 'h</div>';
  html += '<div><strong>üìñ Tiempo estudio:</strong> ' + Math.round(detalle.tiempoEstudio / 60 * 10) / 10 + 'h</div>';
  html += '</div>';
  
  // Estad√≠sticas de progreso
  html += '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">';
  html += '<div style="background: white; padding: 10px; border-radius: 5px;">';
  html += '<div style="font-size: 20px; font-weight: bold; color: #007bff;">' + detalle.temas.length + '</div>';
  html += '<div style="font-size: 12px; color: #666;">Total</div>';
  html += '</div>';
  
  html += '<div style="background: white; padding: 10px; border-radius: 5px;">';
  html += '<div style="font-size: 20px; font-weight: bold; color: #28a745;">' + temasCompletados + '</div>';
  html += '<div style="font-size: 12px; color: #666;">Completados</div>';
  html += '</div>';
  
  html += '<div style="background: white; padding: 10px; border-radius: 5px;">';
  html += '<div style="font-size: 20px; font-weight: bold; color: #ffc107;">' + temasEnProgreso + '</div>';
  html += '<div style="font-size: 12px; color: #666;">En progreso</div>';
  html += '</div>';
  
  html += '<div style="background: white; padding: 10px; border-radius: 5px;">';
  html += '<div style="font-size: 20px; font-weight: bold; color: #6c757d;">' + temasPendientes + '</div>';
  html += '<div style="font-size: 12px; color: #666;">Pendientes</div>';
  html += '</div>';
  html += '</div>';
  
  html += '</div>';
  
  // Lista de temas
  html += '<div style="background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
  html += '<h5 style="margin: 0 0 15px 0;">üìã Temas de la planificaci√≥n</h5>';
  
  if (detalle.temas.length === 0) {
    html += '<p style="text-align: center; color: #666; padding: 20px;">No hay temas en esta planificaci√≥n</p>';
  } else {
    detalle.temas.forEach(tema => {
      // Color y icono seg√∫n estado
      let colorBorde = '#6c757d';
      let colorFondo = '#f8f9fa';
      let icono = '‚≠ï';
      
      if (tema.estado === 'completado') {
        colorBorde = '#28a745';
        colorFondo = '#d4edda';
        icono = '‚úÖ';
      } else if (tema.estado === 'en_progreso') {
        colorBorde = '#ffc107';
        colorFondo = '#fff3cd';
        icono = 'üîÑ';
      }
      
      html += '<div style="border-left: 4px solid ' + colorBorde + '; background: ' + colorFondo + '; padding: 12px; margin-bottom: 10px; border-radius: 5px;">';
      html += '<div style="display: flex; justify-content: space-between; align-items: start;">';
      
      // Informaci√≥n del tema
      html += '<div style="flex: 1;">';
      html += '<div style="font-weight: bold; margin-bottom: 5px;">';
      html += icono + ' ' + tema.nombreCompleto;
      html += '</div>';
      
      // Tiempos
      html += '<div style="font-size: 13px; color: #666;">';
      html += '‚è±Ô∏è Asignado: ' + (tema.tiempoAsignado || 0) + ' min';
      if (tema.tiempoDedicado > 0) {
        html += ' | Dedicado: ' + tema.tiempoDedicado + ' min';
      }
      if (tema.tipoSeleccion) {
        html += ' | Tipo: ' + tema.tipoSeleccion;
      }
      html += '</div>';
      
      // Fecha y nota si est√° completado
      if (tema.estado === 'completado' && tema.fechaCompletado) {
        html += '<div style="font-size: 12px; color: #28a745; margin-top: 5px;">';
        html += '‚úÖ Completado: ' + new Date(tema.fechaCompletado).toLocaleDateString('es-ES');
        html += '</div>';
      }
      
      if (tema.nota) {
        html += '<div style="font-size: 12px; color: #666; margin-top: 5px; font-style: italic;">';
        html += 'üí≠ ' + tema.nota;
        html += '</div>';
      }
      
      html += '</div>';
      
      // Botones de acci√≥n para temas pendientes
      if (tema.estado === 'planificado') {
        html += '<div style="margin-left: 15px;">';
        html += '<button onclick="marcarTemaComoCompletadoDesdeDetalle(' + tema.idProgreso + ', \'' + tema.nombreCompleto.replace(/'/g, "\\'") + '\')" ';
        html += 'style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 3px; font-size: 12px; cursor: pointer;">';
        html += '‚úÖ Completar';
        html += '</button>';
        html += '</div>';
      }
      
      html += '</div>';
      html += '</div>';
    });
  }
  
  html += '</div>';
  
  // Bot√≥n para nueva planificaci√≥n
  html += '<div style="text-align: center; margin-top: 20px;">';
  html += '<button onclick="nuevaPlanificacion()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">';
  html += '‚ûï Nueva Planificaci√≥n';
  html += '</button>';
  html += '</div>';
  
  contenedor.innerHTML = html;
}

// üìÖ FUNCI√ìN 5: Marcar tema como completado desde el detalle
function marcarTemaComoCompletadoDesdeDetalle(idProgreso, nombreTema) {
  const tiempoReal = prompt('‚è±Ô∏è ¬øCu√°ntos minutos dedicaste al tema "' + nombreTema + '"?', '30');
  
  if (!tiempoReal || isNaN(tiempoReal) || tiempoReal < 1) {
    alert('‚ö†Ô∏è Tiempo no v√°lido');
    return;
  }
  
  const nota = prompt('üí≠ Nota personal (opcional):', '');
  
  google.script.run
    .withSuccessHandler(function(resultado) {
      if (resultado.success) {
        alert('üéâ ¬°Tema completado!\n\nSe han programado ' + resultado.repasosCreados + ' repasos autom√°ticamente.');
        // Recargar el detalle
        const idPlanificacion = obtenerIdPlanificacionActual();
        if (idPlanificacion) {
          mostrarDetallePlanificacion(idPlanificacion);
        }
      } else {
        alert('‚ùå Error: ' + resultado.error);
      }
    })
    .withFailureHandler(function(error) {
      alert('‚ùå Error de conexi√≥n: ' + error.message);
    })
    .marcarTemaComoCompletado(idProgreso, parseInt(tiempoReal), nota || null);
}

// üìÖ FUNCI√ìN 6: Actualizar renderizado del calendario para cargar planificaciones
// A√ëADIR al final de la funci√≥n renderizarCalendario() existente:
function renderizarCalendarioConPlanificaciones() {
  // Llamar a la funci√≥n original
  renderizarCalendario();
  
  // Cargar planificaciones despu√©s de renderizar
  setTimeout(() => {
    cargarPlanificacionesEnCalendario();
  }, 100);
}

// üìÖ FUNCI√ìN 7: Actualizar funci√≥n de seleccionar d√≠a para mostrar detalle autom√°ticamente
function seleccionarDiaConDetalle(dia) {
  const fechaSeleccionada = new Date(mesActual.getFullYear(), mesActual.getMonth(), dia);
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  fechaSeleccionada.setHours(0, 0, 0, 0);
  
  const esDiaPasado = fechaSeleccionada < hoy;
  
  diaSeleccionado = dia;
  renderizarCalendario(); // Re-renderizar para mostrar selecci√≥n
  
  // Actualizar t√≠tulo
  const opciones = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
  const tituloFecha = fechaSeleccionada.toLocaleDateString('es-ES', opciones);
  
  document.getElementById('tituloDetalleDia').textContent = tituloFecha + (esDiaPasado ? ' (Solo lectura)' : '');
  
  // Buscar planificaci√≥n para este d√≠a
  buscarPlanificacionDelDia(fechaSeleccionada);
}

// üìÖ FUNCI√ìN 8: Buscar planificaci√≥n espec√≠fica de un d√≠a
function buscarPlanificacionDelDia(fecha) {
  const contenedor = document.getElementById('contenidoDetalleDia');
  contenedor.innerHTML = '<div style="text-align: center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> Buscando planificaci√≥n...</div>';
  
  google.script.run
    .withSuccessHandler(function(planificaciones) {
      if (planificaciones && planificaciones.length > 0) {
        // Hay planificaci√≥n para este d√≠a
        mostrarDetallePlanificacion(planificaciones[0].id);
      } else {
        // No hay planificaci√≥n para este d√≠a
        mostrarDiaSinPlanificacion(fecha);
      }
    })
    .withFailureHandler(function(error) {
      console.error('Error al buscar planificaci√≥n:', error);
      mostrarDiaSinPlanificacion(fecha);
    })
    .getPlanificacionesDelMes(fecha.getFullYear(), fecha.getMonth());
}

// üìÖ FUNCI√ìN 9: Mostrar d√≠a sin planificaci√≥n
function mostrarDiaSinPlanificacion(fecha) {
  const hoy = new Date();
  hoy.setHours(0, 0, 0, 0);
  fecha.setHours(0, 0, 0, 0);
  
  const esFuturo = fecha >= hoy;
  const contenedor = document.getElementById('contenidoDetalleDia');
  
  let html = '<div style="text-align: center; padding: 40px;">';
  
  if (esFuturo) {
    html += '<div style="color: #666; margin-bottom: 20px;">';
    html += '<i class="fas fa-calendar-plus" style="font-size: 48px; opacity: 0.3;"></i>';
    html += '</div>';
    html += '<h4 style="color: #666;">Sin planificaci√≥n</h4>';
    html += '<p style="color: #999; margin-bottom: 20px;">Este d√≠a no tiene planificaci√≥n de estudio.</p>';
    html += '<button onclick="nuevaPlanificacion()" style="background: #28a745; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 16px;">';
    html += '‚ûï Crear Planificaci√≥n';
    html += '</button>';
  } else {
    html += '<div style="color: #999; margin-bottom: 20px;">';
    html += '<i class="fas fa-calendar-times" style="font-size: 48px; opacity: 0.3;"></i>';
    html += '</div>';
    html += '<h4 style="color: #999;">D√≠a pasado sin planificaci√≥n</h4>';
    html += '<p style="color: #666;">Este d√≠a no tuvo planificaci√≥n de estudio.</p>';
  }
  
  html += '</div>';
  
  contenedor.innerHTML = html;
}

// 17. FRONTEND: Interfaz para marcar tema como completado
function mostrarModalCompletarTema(idProgreso, nombreTema) {
  const modal = document.createElement('div');
  modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';
  
  modal.innerHTML = `
    <div style="background: white; padding: 30px; border-radius: 10px; max-width: 500px; width: 90%;">
      <h4>‚úÖ Completar tema</h4>
      <p><strong>Tema:</strong> ${nombreTema}</p>
      
      <label style="display: block; margin: 15px 0 5px 0;">Tiempo real dedicado (minutos):</label>
      <input type="number" id="tiempoRealDedicado" min="1" max="600" value="30" style="width: 100%; padding: 8px;">
      
      <label style="display: block; margin: 15px 0 5px 0;">Nota personal (opcional):</label>
      <textarea id="notaPersonal" rows="3" style="width: 100%; padding: 8px;" placeholder="¬øC√≥mo te ha ido? ¬øQu√© has aprendido?"></textarea>
      
      <div style="text-align: center; margin-top: 20px;">
        <button onclick="cerrarModalCompletar()" style="background: #6c757d; color: white; padding: 10px 20px; border: none; border-radius: 5px; margin-right: 10px;">
          Cancelar
        </button>
        <button onclick="confirmarCompletarTema(${idProgreso})" style="background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 5px;">
          ‚úÖ Marcar como completado
        </button>
      </div>
    </div>
  `;
  
  modal.id = 'modalCompletarTema';
  document.body.appendChild(modal);
}

// 18. FRONTEND: Confirmar completar tema
function confirmarCompletarTema(idProgreso) {
  const tiempoReal = parseInt(document.getElementById('tiempoRealDedicado').value);
  const nota = document.getElementById('notaPersonal').value.trim();
  
  if (!tiempoReal || tiempoReal < 1) {
    alert('‚ö†Ô∏è Introduce un tiempo v√°lido (m√≠nimo 1 minuto)');
    return;
  }
  
  // Deshabilitar bot√≥n
  const btn = document.querySelector('button[onclick="confirmarCompletarTema(' + idProgreso + ')"]');
  btn.disabled = true;
  btn.textContent = '‚è≥ Completando...';
  
  // Llamar al backend
  google.script.run
    .withSuccessHandler(function(resultado) {
      if (resultado.success) {
        alert('üéâ ¬°Tema completado!\n\n' +
              `üîÑ Se han programado ${resultado.repasosCreados} repasos autom√°ticamente.\n\n` +
              'Los repasos aparecer√°n en d√≠as futuros seg√∫n el sistema de repetici√≥n espaciada.');
        
        cerrarModalCompletar();
        
        // Actualizar la interfaz si es necesario
        if (typeof actualizarDetallePlanificacion === 'function') {
          actualizarDetallePlanificacion();
        }
      } else {
        alert('‚ùå Error al completar tema: ' + resultado.error);
        btn.disabled = false;
        btn.textContent = '‚úÖ Marcar como completado';
      }
    })
    .withFailureHandler(function(error) {
      alert('‚ùå Error de conexi√≥n: ' + error.message);
      btn.disabled = false;
      btn.textContent = '‚úÖ Marcar como completado';
    })
    .marcarTemaComoCompletado(idProgreso, tiempoReal, nota || null);
}

// 19. FRONTEND: Cerrar modal de completar
function cerrarModalCompletar() {
  const modal = document.getElementById('modalCompletarTema');
  if (modal) {
    modal.remove();
  }
}

// 20. BACKEND: Obtener progreso de temas de una planificaci√≥n espec√≠fica
function getProgresoTemasPlanificacion(idPlanificacion) {
  try {
    const progresoSheet = getGoogleSheet('Progreso_Temas');
    const progresoColumns = getColumnIndices('Progreso_Temas');
    const data = progresoSheet.getDataRange().getValues();
    
    const temas = [];
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][progresoColumns['id_planificacion']] == idPlanificacion) {
        const idTema = data[i][progresoColumns['id_tema']];
        const tema = getTemaById(idTema);
        
        temas.push({
          idProgreso: data[i][progresoColumns['id_progreso']],
          idTema: idTema,
          nombre: tema.nombre,
          prenombre: tema.prenombre,
          nombreCompleto: (tema.prenombre || '') + ' ' + tema.nombre,
          tiempoAsignado: data[i][progresoColumns['tiempo_asignado_minutos']],
          tiempoDedicado: data[i][progresoColumns['tiempo_dedicado_minutos']] || 0,
          estado: data[i][progresoColumns['estado']],
          tipoSeleccion: data[i][progresoColumns['tipo_seleccion']],
          fechaCompletado: data[i][progresoColumns['fecha_completado']],
          nota: data[i][progresoColumns['nota']] || ''
        });
      }
    }
    
    return temas;
    
  } catch (error) {
    console.error('Error al obtener progreso de temas:', error);
    return [];
  }
}






// Event listener para cambio de horas
document.addEventListener('DOMContentLoaded', function() {
  // Solo a√±adir el listener si el elemento existe
  setTimeout(function() {
    const horasInput = document.getElementById('horasEstudio');
    if (horasInput) {
      horasInput.addEventListener('input', actualizarTiempoDisponible);
    }
  }, 100);
});

// Event listeners para el modal
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(function() {
    // Listener para cambio de fecha
    const fechaInput = document.getElementById('fechaPlanificacion');
    if (fechaInput) {
      fechaInput.addEventListener('change', verificarRepasosDelDia);
    }
    
    // Listener para cambio de oposici√≥n
    const oposicionSelect = document.getElementById('oposicionPlanificacion');
    if (oposicionSelect) {
      oposicionSelect.addEventListener('change', function() {
        if (pasoActual >= 2) {
          cargarConfiguracionActual();
        }
      });
    }
    
    // Listener para cambio de horas
    const horasInput = document.getElementById('horasEstudio');
    if (horasInput) {
      horasInput.addEventListener('input', actualizarTiempoDisponible);
    }
  }, 100);
});

// Validar orden consecutivo de temas
// CORRECCI√ìN: En scriptsPlanificacion.html
// Reemplazar la funci√≥n validarOrdenConsecutivo() existente

function validarOrdenConsecutivo(nodoSeleccionado, arbolCompleto) {
  console.log('üîç Validando orden SOLO dentro del mismo bloque y tema padre para:', nodoSeleccionado.id);
  
  // 1. Obtener el tema que se quiere seleccionar
  const nodoCompleto = encontrarNodoEnArbolCompleto(nodoSeleccionado.id, arbolCompleto);
  if (!nodoCompleto) {
    console.log('‚ùå Nodo no encontrado');
    return { esConsecutivo: true };
  }
  
  // 2. Obtener el tema padre original del nodo seleccionado
  const temaPadreOriginal = obtenerTemaPadreOriginal(nodoCompleto, arbolCompleto);
  console.log('üë®‚Äçüëß‚Äçüë¶ Tema padre original del nuevo tema:', temaPadreOriginal.nombreCompleto);
  
  // 3. Obtener el bloque del tema seleccionado
  const bloqueDelTema = obtenerBloqueDelTema(nodoCompleto.id);
  console.log('üì¶ Bloque del tema:', bloqueDelTema);
  
  // 4. Filtrar temas ya seleccionados DEL MISMO BLOQUE
  const temasDelMismoBloque = temasSeleccionados.filter(t => t.bloque === bloqueDelTema);
  console.log('üìã Temas ya seleccionados del mismo bloque:', temasDelMismoBloque.length);
  
  if (temasDelMismoBloque.length === 0) {
    console.log('‚úÖ Primer tema del bloque - libre elecci√≥n');
    return { esConsecutivo: true };
  }
  
  // 5. Verificar si alg√∫n tema del mismo bloque pertenece al mismo tema padre original
  let hayTemasDelMismoTemaPadre = false;
  
  for (const temaDelBloque of temasDelMismoBloque) {
    const nodoExistente = encontrarNodoEnArbolCompleto(temaDelBloque.id, arbolCompleto);
    if (nodoExistente) {
      const temaPadreOriginalExistente = obtenerTemaPadreOriginal(nodoExistente, arbolCompleto);
      
      if (temaPadreOriginalExistente.id === temaPadreOriginal.id) {
        hayTemasDelMismoTemaPadre = true;
        break;
      }
    }
  }
  
  if (!hayTemasDelMismoTemaPadre) {
    console.log('‚úÖ Primer tema de este tema padre original en el bloque - libre elecci√≥n');
    return { esConsecutivo: true };
  }
  
  console.log('üîç Hay temas del mismo tema padre original - validando orden...');
  
  // 6. Generar orden plano SOLO de este tema padre original
  const ordenDelTemaPadre = generarOrdenPlanoDelTemaPadre(temaPadreOriginal);
  
  console.log('üìã Orden del tema padre original:');
  ordenDelTemaPadre.forEach((tema, index) => {
    console.log(`   ${index}: ${tema.prenombre || ''} ${tema.nombre} (ID: ${tema.id})`);
  });
  
  // 7. Encontrar posici√≥n del tema seleccionado dentro de su tema padre original
  const posicionEnTemaPadre = ordenDelTemaPadre.findIndex(tema => tema.id === nodoSeleccionado.id);
  
  if (posicionEnTemaPadre === -1) {
    console.log('‚ùå Tema no encontrado en orden del tema padre');
    return { esConsecutivo: true };
  }
  
  console.log('üìç Posici√≥n en tema padre:', posicionEnTemaPadre);
  
  // 8. Verificar temas anteriores SOLO del mismo tema padre original
  const temasAnterioresEnTemaPadre = ordenDelTemaPadre.slice(0, posicionEnTemaPadre);
  console.log('‚èÆÔ∏è Temas anteriores en tema padre a verificar:', temasAnterioresEnTemaPadre.length);
  
  // 9. Verificar cu√°les faltan (considerando descendientes)
  const temasSaltados = [];
  
  for (const temaAnterior of temasAnterioresEnTemaPadre) {
    const estaSeleccionadoOCompleto = verificarSiTemaEstaSeleccionadoCompleto(temaAnterior.id, arbolCompleto, bloqueDelTema);
    
    console.log(`   Verificando ${temaAnterior.prenombre || ''} ${temaAnterior.nombre}: ${estaSeleccionadoOCompleto ? 'OK' : 'FALTA'}`);
    
    if (!estaSeleccionadoOCompleto) {
      temasSaltados.push(temaAnterior);
    }
  }
  
  console.log('‚ö†Ô∏è Temas saltados en tema padre:', temasSaltados.length);
  
  // 10. Si hay temas saltados ‚Üí advertencia
  if (temasSaltados.length > 0) {
    const mensaje = 'Orden alterado dentro del tema padre original üìä\n\n' +
                   'Tema padre original: "' + temaPadreOriginal.nombreCompleto + '"\n' +
                   'Bloque: "' + bloqueDelTema + '"\n\n' +
                   'Te est√°s saltando temas en el orden:\n\n' + 
                   temasSaltados.slice(0, 3).map(t => '‚Ä¢ ' + (t.prenombre || '') + ' ' + t.nombre).join('\n') +
                   (temasSaltados.length > 3 ? '\n... y ' + (temasSaltados.length - 3) + ' m√°s' : '') + '\n\n' +
                   'Tema que quieres seleccionar: ' + (nodoCompleto.prenombre || '') + ' ' + nodoCompleto.nombre + '\n\n' +
                   '¬øQuieres continuar salt√°ndote el orden?';
    
    return {
      esConsecutivo: false,
      mensaje: mensaje,
      temasSaltados: temasSaltados,
      requiereAdvertencia: true,
      temaPadreOriginal: temaPadreOriginal.nombreCompleto
    };
  }
  
  console.log('‚úÖ Orden respetado dentro del tema padre original');
  return { esConsecutivo: true };
}

// üîß CORRECCI√ìN 1: Funci√≥n mejorada para obtener bloque del tema
function obtenerBloqueDelTema(idTema) {
  console.log('üîç Obteniendo bloque para tema:', idTema);
  
  // 1. Buscar en temas ya seleccionados (m√°s r√°pido)
  const temaSeleccionado = temasSeleccionados.find(t => t.id === idTema);
  if (temaSeleccionado && temaSeleccionado.bloque) {
    console.log('‚úÖ Bloque encontrado en seleccionados:', temaSeleccionado.bloque);
    return temaSeleccionado.bloque;
  }
  
  // 2. Buscar en el √°rbol completo global
  if (window.arbolCompletoGlobal) {
    const nodo = encontrarNodoEnArbolCompleto(idTema, window.arbolCompletoGlobal);
    if (nodo && nodo.idBloque) {
      // Obtener nombre del bloque desde los datos globales
      const nombreBloque = window.bloquesInfoGlobal ? window.bloquesInfoGlobal[nodo.idBloque] : `Bloque_${nodo.idBloque}`;
      console.log('‚úÖ Bloque encontrado en √°rbol:', nombreBloque);
      return nombreBloque;
    }
  }
  
  // 3. Buscar en todos los elementos de la interfaz como √∫ltimo recurso
  const todosLosCheckboxes = document.querySelectorAll('input[type="checkbox"]');
  for (let checkbox of todosLosCheckboxes) {
    const onchangeAttr = checkbox.getAttribute('onchange');
    if (onchangeAttr) {
      const match = onchangeAttr.match(/toggleSeleccionTemaConValidacion\(this,\s*(\d+),\s*\d+,\s*'([^']+)'/);
      if (match && parseInt(match[1]) === idTema) {
        console.log('‚úÖ Bloque encontrado en interfaz:', match[2]);
        return match[2];
      }
    }
  }
  
  console.warn('‚ö†Ô∏è No se pudo determinar el bloque para tema:', idTema);
  return 'Bloque_Desconocido';
}

// üîß CORRECCI√ìN 2: Funci√≥n simplificada para verificar tema completo
function verificarSiTemaEstaSeleccionadoCompleto(idTema, arbolCompleto, bloqueEspecifico) {
  console.log('üîç Verificando completitud del tema:', idTema, 'en bloque:', bloqueEspecifico);
  
  // 1. ‚úÖ SELECCI√ìN DIRECTA en el mismo bloque
  const seleccionDirecta = temasSeleccionados.some(t => 
    t.id === idTema && t.bloque === bloqueEspecifico
  );
  if (seleccionDirecta) {
    console.log('   ‚úÖ Seleccionado directamente');
    return true;
  }
  
  // 2. ‚úÖ ESTADO COMPLETADO (de sesiones anteriores)
  const nodoTema = encontrarNodoEnArbolCompleto(idTema, arbolCompleto);
  if (nodoTema && nodoTema.estado === 'completado') {
    console.log('   ‚úÖ Completado anteriormente');
    return true;
  }
  
  // 3. ‚úÖ INCLUIDO POR PADRE (selecci√≥n de tema padre completo)
  if (nodoTema) {
    // Buscar si alg√∫n ancestro directo est√° seleccionado como 'padre'
    const ancestrosDirectos = obtenerAncestrosDirectos(nodoTema, arbolCompleto);
    
    for (const ancestro of ancestrosDirectos) {
      const ancestroSeleccionadoComoPadre = temasSeleccionados.some(t => 
        t.id === ancestro.id && 
        t.tipo === 'padre' && 
        t.bloque === bloqueEspecifico
      );
      
      if (ancestroSeleccionadoComoPadre) {
        console.log('   ‚úÖ Incluido por ancestro padre:', ancestro.nombreCompleto);
        return true;
      }
    }
  }
  
  console.log('   ‚ùå No est√° completo');
  return false;
}

// üîß CORRECCI√ìN 3: Nueva funci√≥n para obtener ancestros directos
function obtenerAncestrosDirectos(nodo, arbolCompleto) {
  const ancestros = [];
  let nodoActual = nodo;
  
  while (nodoActual) {
    const padreDirecto = obtenerTemaPadreReal(nodoActual, arbolCompleto);
    if (padreDirecto) {
      ancestros.push(padreDirecto);
      nodoActual = padreDirecto;
    } else {
      break;
    }
  }
  
  return ancestros;
}

// üîß CORRECCI√ìN 4: Funci√≥n de validaci√≥n de orden mejorada y simplificada
function validarOrdenConsecutivoMejorado(nodoSeleccionado, arbolCompleto) {
  console.log('üîç === VALIDACI√ìN DE ORDEN MEJORADA ===');
  console.log('üéØ Validando tema:', nodoSeleccionado.id);
  
  // 1. Obtener informaci√≥n del tema seleccionado
  const nodoCompleto = encontrarNodoEnArbolCompleto(nodoSeleccionado.id, arbolCompleto);
  if (!nodoCompleto) {
    console.log('‚ùå Nodo no encontrado');
    return { esConsecutivo: true };
  }
  
  const temaPadreOriginal = obtenerTemaPadreOriginal(nodoCompleto, arbolCompleto);
  const bloqueDelTema = obtenerBloqueDelTema(nodoCompleto.id);
  
  console.log('üë®‚Äçüëß‚Äçüë¶ Tema padre original:', temaPadreOriginal.nombreCompleto);
  console.log('üì¶ Bloque:', bloqueDelTema);
  
  // 2. Obtener temas ya seleccionados del mismo bloque
  const temasDelMismoBloque = temasSeleccionados.filter(t => t.bloque === bloqueDelTema);
  console.log('üìã Temas del mismo bloque ya seleccionados:', temasDelMismoBloque.length);
  
  if (temasDelMismoBloque.length === 0) {
    console.log('‚úÖ Primer tema del bloque - LIBRE ELECCI√ìN');
    return { esConsecutivo: true };
  }
  
  // 3. Verificar si hay temas del mismo tema padre original en el bloque
  let hayTemasDelMismoTemaPadre = false;
  for (const temaDelBloque of temasDelMismoBloque) {
    const nodoExistente = encontrarNodoEnArbolCompleto(temaDelBloque.id, arbolCompleto);
    if (nodoExistente) {
      const temaPadreOriginalExistente = obtenerTemaPadreOriginal(nodoExistente, arbolCompleto);
      if (temaPadreOriginalExistente.id === temaPadreOriginal.id) {
        hayTemasDelMismoTemaPadre = true;
        break;
      }
    }
  }
  
  if (!hayTemasDelMismoTemaPadre) {
    console.log('‚úÖ Primer tema de este tema padre en el bloque - LIBRE ELECCI√ìN');
    return { esConsecutivo: true };
  }
  
  console.log('üîç Hay temas del mismo tema padre - VALIDANDO ORDEN...');
  
  // 4. Generar orden plano SOLO del tema padre original
  const ordenDelTemaPadre = generarOrdenPlanoDelTemaPadre(temaPadreOriginal);
  console.log('üìã Orden del tema padre (' + ordenDelTemaPadre.length + ' temas):');
  ordenDelTemaPadre.forEach((tema, index) => {
    console.log(`   ${index + 1}. ${tema.prenombre || ''} ${tema.nombre} (ID: ${tema.id})`);
  });
  
  // 5. Encontrar posici√≥n del tema seleccionado
  const posicionEnTemaPadre = ordenDelTemaPadre.findIndex(tema => tema.id === nodoSeleccionado.id);
  if (posicionEnTemaPadre === -1) {
    console.log('‚ùå Tema no encontrado en orden');
    return { esConsecutivo: true }; // Si no se puede determinar, permitir
  }
  
  console.log('üìç Posici√≥n del tema seleccionado:', posicionEnTemaPadre + 1);
  
  // 6. Verificar temas anteriores que faltan
  const temasAnteriores = ordenDelTemaPadre.slice(0, posicionEnTemaPadre);
  const temasSaltados = [];
  
  console.log('‚èÆÔ∏è Verificando', temasAnteriores.length, 'temas anteriores...');
  
  for (const temaAnterior of temasAnteriores) {
    const estaCompleto = verificarSiTemaEstaSeleccionadoCompleto(temaAnterior.id, arbolCompleto, bloqueDelTema);
    console.log(`   ${temaAnterior.prenombre || ''} ${temaAnterior.nombre}: ${estaCompleto ? '‚úÖ OK' : '‚ùå FALTA'}`);
    
    if (!estaCompleto) {
      temasSaltados.push(temaAnterior);
    }
  }
  
  // 7. Resultado final
  if (temasSaltados.length > 0) {
    console.log('‚ö†Ô∏è ORDEN ALTERADO - Temas saltados:', temasSaltados.length);
    
    const mensaje = 'üìä Orden alterado dentro del tema padre\n\n' +
                   `Tema padre: "${temaPadreOriginal.nombreCompleto}"\n` +
                   `Bloque: "${bloqueDelTema}"\n\n` +
                   'Temas que te saltas:\n' + 
                   temasSaltados.slice(0, 3).map(t => `‚Ä¢ ${t.prenombre || ''} ${t.nombre}`).join('\n') +
                   (temasSaltados.length > 3 ? `\n... y ${temasSaltados.length - 3} m√°s` : '') + '\n\n' +
                   `Tema que quieres: ${nodoCompleto.prenombre || ''} ${nodoCompleto.nombre}\n\n` +
                   '¬øContinuar salt√°ndote el orden?';
    
    return {
      esConsecutivo: false,
      mensaje: mensaje,
      temasSaltados: temasSaltados,
      requiereAdvertencia: true,
      temaPadreOriginal: temaPadreOriginal.nombreCompleto
    };
  }
  
  console.log('‚úÖ ORDEN RESPETADO');
  return { esConsecutivo: true };
}

// NUEVA FUNCI√ìN: Verificar si un tema est√° seleccionado (considerando padre vs hijos)
function verificarSiTemaEstaSeleccionado(idTema, arbolCompleto) {
  console.log('üîç Verificando si tema est√° seleccionado:', idTema);
  
  // 1. Verificar si el tema est√° directamente en la lista
  const seleccionDirecta = temasSeleccionados.some(t => t.id === idTema);
  if (seleccionDirecta) {
    console.log('   ‚úÖ Selecci√≥n directa encontrada');
    return true;
  }
  
  // 2. Verificar si el tema est√° incluido por selecci√≥n de su padre
  const nodoTema = encontrarNodoEnArbolCompleto(idTema, arbolCompleto);
  if (!nodoTema) {
    console.log('   ‚ùå Nodo no encontrado');
    return false;
  }
  
  // 3. Buscar si alg√∫n ancestro est√° seleccionado como "padre"
  let nodoActual = nodoTema;
  while (nodoActual) {
    const padreDirecto = obtenerTemaPadreReal(nodoActual, arbolCompleto);
    if (!padreDirecto) break;
    
    // Verificar si el padre directo est√° seleccionado como tema padre (tipo: 'padre')
    const padreSeleccionadoCompleto = temasSeleccionados.some(t => 
      t.id === padreDirecto.id && t.tipo === 'padre'
    );
    
    if (padreSeleccionadoCompleto) {
      console.log('   ‚úÖ Incluido por selecci√≥n del padre:', padreDirecto.nombreCompleto);
      return true;
    }
    
    nodoActual = padreDirecto;
  }
  
  console.log('   ‚ùå No est√° seleccionado');
  return false;
}

// Mantener la funci√≥n existente para generar orden plano
function generarOrdenPlanoCompleto(arbol) {
  const ordenPlano = [];
  
  function recorrerRecursivamente(nodos, nivel = 0) {
    // Ordenar nodos por prenombre antes de procesarlos
    const nodosOrdenados = nodos.sort((a, b) => {
      const numA = parseFloat((a.prenombre || '0').replace(/[^\d.]/g, ''));
      const numB = parseFloat((b.prenombre || '0').replace(/[^\d.]/g, ''));
      return numA - numB;
    });
    
    nodosOrdenados.forEach(nodo => {
      // A√±adir el nodo actual al orden plano
      ordenPlano.push({
        id: nodo.id,
        nombre: nodo.nombre,
        prenombre: nodo.prenombre,
        nombreCompleto: nodo.nombreCompleto,
        estado: nodo.estado,
        nivel: nivel
      });
      
      // Procesar hijos recursivamente
      if (nodo.hijos && nodo.hijos.length > 0) {
        recorrerRecursivamente(nodo.hijos, nivel + 1);
      }
    });
  }
  
  recorrerRecursivamente(arbol);
  
  console.log('üå≥ Orden plano generado con', ordenPlano.length, 'temas');
  return ordenPlano;
}

// Funci√≥n para generar orden plano COMPLETO del √°rbol
function generarOrdenPlanoCompleto(arbol) {
  const ordenPlano = [];
  
  function recorrerRecursivamente(nodos, nivel = 0) {
    // Ordenar nodos por prenombre antes de procesarlos
    const nodosOrdenados = nodos.sort((a, b) => {
      const numA = parseFloat((a.prenombre || '0').replace(/[^\d.]/g, ''));
      const numB = parseFloat((b.prenombre || '0').replace(/[^\d.]/g, ''));
      return numA - numB;
    });
    
    nodosOrdenados.forEach(nodo => {
      // A√±adir el nodo actual al orden plano
      ordenPlano.push({
        id: nodo.id,
        nombre: nodo.nombre,
        prenombre: nodo.prenombre,
        nombreCompleto: nodo.nombreCompleto,
        estado: nodo.estado,
        nivel: nivel
      });
      
      // Procesar hijos recursivamente
      if (nodo.hijos && nodo.hijos.length > 0) {
        recorrerRecursivamente(nodo.hijos, nivel + 1);
      }
    });
  }
  
  recorrerRecursivamente(arbol);
  
  console.log('üå≥ Orden plano generado con', ordenPlano.length, 'temas');
  return ordenPlano;
}

// Funci√≥n auxiliar para verificar si el padre est√° seleccionado como tema completo
function verificarSiPadreEstaSeleccionadoComoTodo(nodo, arbolCompleto) {
  const padreDirecto = obtenerTemaPadreReal(nodo, arbolCompleto);
  if (!padreDirecto) return false;
  
  // Verificar si el padre directo est√° seleccionado como "padre" (tema completo)
  return temasSeleccionados.some(t => t.id === padreDirecto.id && t.tipo === 'padre');
}

// Funci√≥n auxiliar para verificar excepci√≥n por tiempo espec√≠fica
function verificarExcepcionPorTiempoParaTema(nodo, arbolCompleto) {
  // Obtener el tema padre directo del nodo
  const padreDirecto = obtenerTemaPadreReal(nodo, arbolCompleto);
  if (!padreDirecto) return false;
  
  // Si el padre directo tiene tiempo definido y NO cabe en el tiempo restante
  const tiempoRestante = tiempoTotalDisponible - tiempoUsado;
  const tiempoPadreDirecto = padreDirecto.tiempoMinutos || 0;
  
  if (tiempoPadreDirecto > tiempoRestante && tiempoPadreDirecto > 0) {
    console.log('‚è±Ô∏è Excepci√≥n por tiempo para:', nodo.prenombre + ' ' + nodo.nombre);
    console.log('   Padre directo:', padreDirecto.nombreCompleto, 'necesita', tiempoPadreDirecto, 'min');
    console.log('   Tiempo restante:', tiempoRestante, 'min');
    return true;
  }
  
  return false;
}

// Funci√≥n auxiliar para verificar si el padre directo est√° seleccionado como tema padre
function verificarSiPadreDirectoEstaSeleccionado(nodo, arbolCompleto) {
  const padreDirecto = obtenerTemaPadreReal(nodo, arbolCompleto);
  if (!padreDirecto) return false;
  
  return temasSeleccionados.some(t => t.id === padreDirecto.id && t.tipo === 'padre');
}

// Funci√≥n auxiliar mejorada para verificar excepci√≥n por tiempo
function verificarExcepcionPorTiempoDetallada(nodo, arbolCompleto) {
  // Obtener el tema padre directo del nodo
  const padreDirecto = obtenerTemaPadreReal(nodo, arbolCompleto);
  if (!padreDirecto) return false;
  
  // Si el padre directo tiene tiempo definido y no cabe en el tiempo restante
  const tiempoRestante = tiempoTotalDisponible - tiempoUsado;
  const tiempoPadreDirecto = padreDirecto.tiempoMinutos || 0;
  
  if (tiempoPadreDirecto > tiempoRestante && tiempoPadreDirecto > 0) {
    console.log('‚è±Ô∏è Excepci√≥n por tiempo detectada para padre directo:', 
               padreDirecto.nombreCompleto, 
               'Tiempo padre:', tiempoPadreDirecto, 'min, Restante:', tiempoRestante, 'min');
    return true;
  }
  
  return false;
}

// Funci√≥n auxiliar para generar orden plano del √°rbol
function generarOrdenPlanoDelArbol(arbol) {
  const ordenPlano = [];
  
  function recorrerNodos(nodos) {
    nodos.forEach(nodo => {
      // Solo a√±adir nodos que pueden ser seleccionados (hojas o padres sin tiempo espec√≠fico)
      if (nodo.esHoja || (nodo.hijos && nodo.hijos.length > 0)) {
        ordenPlano.push(nodo);
      }
      
      // Recorrer hijos recursivamente
      if (nodo.hijos && nodo.hijos.length > 0) {
        recorrerNodos(nodo.hijos);
      }
    });
  }
  
  recorrerNodos(arbol);
  
  // Ordenar por prenombre num√©rico
  return ordenPlano.sort((a, b) => {
    const numA = parseFloat((a.prenombre || '0').replace(/[^\d.]/g, ''));
    const numB = parseFloat((b.prenombre || '0').replace(/[^\d.]/g, ''));
    return numA - numB;
  });
}

// Funci√≥n auxiliar para verificar si el padre est√° seleccionado
function verificarSiPadreEstaSeleccionado(nodo, arbolCompleto) {
  const padre = obtenerTemaPadreReal(nodo, arbolCompleto);
  if (!padre) return false;
  
  return temasSeleccionados.some(t => t.id === padre.id && t.tipo === 'padre');
}

// Funci√≥n auxiliar para verificar excepci√≥n por tiempo
function verificarExcepcionPorTiempo(nodo, arbolCompleto) {
  // Obtener el tema padre
  const padre = obtenerTemaPadreReal(nodo, arbolCompleto);
  if (!padre) return false;
  
  // Si el padre tiene tiempo definido y no cabe en el tiempo restante
  const tiempoRestante = tiempoTotalDisponible - tiempoUsado;
  const tiempoPadre = padre.tiempo || 0;
  
  if (tiempoPadre > tiempoRestante && tiempoPadre > 0) {
    console.log('‚è±Ô∏è Excepci√≥n por tiempo detectada para:', padre.nombreCompleto, 
               'Tiempo padre:', tiempoPadre, 'Restante:', tiempoRestante);
    return true;
  }
  
  return false;
}

function manejarAdvertenciaConDobleNivel(tipoAdvertencia, claveAdvertencia, mensaje, idTema, callback) {
  console.log('‚ö†Ô∏è Manejando advertencia:', tipoAdvertencia, 'clave:', claveAdvertencia);
  
  // Inicializar contadores si no existen
  if (tipoAdvertencia === 'orden') {
    if (!advertenciasOrdenMostradas[claveAdvertencia]) {
      advertenciasOrdenMostradas[claveAdvertencia] = 0;
    }
    advertenciasOrdenMostradas[claveAdvertencia]++;
    
    const veces = advertenciasOrdenMostradas[claveAdvertencia];
    console.log('üìä Advertencia de orden mostrada', veces, 'veces para:', claveAdvertencia);
    
    if (veces === 1) {
      // PRIMERA VEZ: Advertir y NO permitir
      alert('üö´ PRIMERA ADVERTENCIA - No permitido\n\n' + mensaje + 
           '\n\n‚ùå Esta vez NO se permitir√° la selecci√≥n.' +
           '\n‚úÖ Si insistes, la pr√≥xima vez S√ç se permitir√°.');
      return false; // No permitir
      
    } else {
      // SEGUNDA VEZ O M√ÅS: Advertir pero S√ç permitir
      const confirmar = confirm('‚ö†Ô∏è SEGUNDA ADVERTENCIA - Libertad total\n\n' + mensaje + 
                               '\n\n‚úÖ Esta vez S√ç puedes continuar si quieres.' +
                               '\nüîÑ Tienes libertad total para organizar tu estudio.' +
                               '\n\n¬øQuieres continuar?');
      return confirmar; // Permitir si confirma
    }
    
  } else if (tipoAdvertencia === 'bloques') {
    if (!advertenciasBloquesMostradas[claveAdvertencia]) {
      advertenciasBloquesMostradas[claveAdvertencia] = 0;
    }
    advertenciasBloquesMostradas[claveAdvertencia]++;
    
    const veces = advertenciasBloquesMostradas[claveAdvertencia];
    console.log('üìä Advertencia de bloques mostrada', veces, 'veces para:', claveAdvertencia);
    
    if (veces === 1) {
      // PRIMERA VEZ: Advertir y NO permitir
      alert('üö´ PRIMERA ADVERTENCIA - No permitido\n\n' + mensaje + 
           '\n\n‚ùå Esta vez NO se permitir√° la selecci√≥n.' +
           '\n‚úÖ Si insistes, la pr√≥xima vez S√ç se permitir√°.');
      return false; // No permitir
      
    } else {
      // SEGUNDA VEZ O M√ÅS: Advertir pero S√ç permitir
      const confirmar = confirm('‚ö†Ô∏è SEGUNDA ADVERTENCIA - Libertad total\n\n' + mensaje + 
                               '\n\n‚úÖ Esta vez S√ç puedes continuar si quieres.' +
                               '\nüîÑ Tienes libertad total para organizar tu estudio.' +
                               '\n\n¬øQuieres continuar?');
      return confirmar; // Permitir si confirma
    }
  }
  
  return true; // Por defecto permitir
}

// Funci√≥n para resetear advertencias (√∫til al crear nueva planificaci√≥n)
function resetearAdvertencias() {
  advertenciasOrdenMostradas = {};
  advertenciasBloquesMostradas = {};
  console.log('üîÑ Advertencias reseteadas');
}

// CORRECCI√ìN 24: En scriptsPlanificacion.html
// A√ëADIR estas nuevas funciones (no reemplazar)

function obtenerTemaPadreOriginal(nodo, arbolCompleto) {
  console.log('üîç Buscando tema padre original para:', nodo.nombreCompleto);
  
  // Buscar recursivamente hacia arriba hasta encontrar el tema padre original (sin id_padre)
  function buscarHaciaArriba(nodoActual) {
    // Si este nodo no tiene id_padre, es un tema padre original
    if (!nodoActual.idPadre) {
      return nodoActual;
    }
    
    // Buscar el padre de este nodo
    const padre = encontrarNodoEnArbolCompleto(nodoActual.idPadre, arbolCompleto);
    if (!padre) {
      console.log('‚ùå No se encontr√≥ el padre con id:', nodoActual.idPadre);
      return nodoActual; // Si no se encuentra el padre, asumir que este es el original
    }
    
    // Continuar buscando hacia arriba
    return buscarHaciaArriba(padre);
  }
  
  const temaPadreOriginal = buscarHaciaArriba(nodo);
  console.log('‚úÖ Tema padre original encontrado:', temaPadreOriginal.nombreCompleto);
  return temaPadreOriginal;
}

function obtenerTemasPadreOriginalesSeleccionados() {
  const temasPadreOriginales = new Set();
  const detallesPorPadre = {};
  
  temasSeleccionados.forEach(temaSeleccionado => {
    const nodo = encontrarNodoEnArbolCompleto(temaSeleccionado.id, window.arbolCompletoGlobal);
    if (nodo) {
      const temaPadreOriginal = obtenerTemaPadreOriginal(nodo, window.arbolCompletoGlobal);
      const idPadreOriginal = temaPadreOriginal.id;
      
      temasPadreOriginales.add(idPadreOriginal);
      
      if (!detallesPorPadre[idPadreOriginal]) {
        detallesPorPadre[idPadreOriginal] = {
          padre: temaPadreOriginal,
          temasSeleccionados: [],
          bloque: temaSeleccionado.bloque
        };
      }
      detallesPorPadre[idPadreOriginal].temasSeleccionados.push(temaSeleccionado);
    }
  });
  
  console.log('üìä Temas padre originales seleccionados:', Array.from(temasPadreOriginales));
  console.log('üìä Detalles por padre original:', detallesPorPadre);
  
  return { ids: temasPadreOriginales, detalles: detallesPorPadre };
}

function verificarSiDebiaContinuarTemaPadreOriginal(nodoNuevo, nombreBloque) {
  console.log('üîç Verificando si deb√≠a continuar tema padre original para:', nodoNuevo.nombreCompleto);
  
  // Obtener tema padre original del nuevo nodo
  const temaPadreOriginalNuevo = obtenerTemaPadreOriginal(nodoNuevo, window.arbolCompletoGlobal);
  
  // Obtener temas padre originales ya seleccionados del mismo bloque
  const { detalles } = obtenerTemasPadreOriginalesSeleccionados();
  
  // Filtrar solo los del mismo bloque
  const padresOriginalesDelMismoBloque = Object.values(detalles).filter(d => d.bloque === nombreBloque);
  
  if (padresOriginalesDelMismoBloque.length === 0) {
    console.log('‚úÖ No hay temas padre originales del mismo bloque - libre elecci√≥n');
    return { debiaContinuar: false };
  }
  
  // Verificar si el nuevo tema pertenece a alg√∫n tema padre original ya empezado
  const perteneceAPadreYaEmpezado = padresOriginalesDelMismoBloque.some(d => 
    d.padre.id === temaPadreOriginalNuevo.id
  );
  
  if (perteneceAPadreYaEmpezado) {
    console.log('‚úÖ Pertenece a tema padre original ya empezado - correcto');
    return { debiaContinuar: false }; // Es correcto continuar
  }
  
  // Verificar si hay temas padre originales con progreso que ser√≠a mejor continuar
  const padresConProgreso = padresOriginalesDelMismoBloque.filter(d => {
    // Verificar si tiene hijos incompletos
    const todosLosHijosDelPadre = obtenerTodosLosDescendientes(d.padre, window.arbolCompletoGlobal);
    const hijosSeleccionados = d.temasSeleccionados.map(t => t.id);
    const hijosIncompletos = todosLosHijosDelPadre.filter(hijo => 
      !hijosSeleccionados.includes(hijo.id) && hijo.estado !== 'completado'
    );
    
    return hijosIncompletos.length > 0; // Tiene hijos pendientes
  });
  
  if (padresConProgreso.length > 0) {
    const padreARecomendar = padresConProgreso[0];
    return {
      debiaContinuar: true,
      mensaje: 'Recomendaci√≥n de continuidad üìö\n\n' +
               'Ya tienes progreso en el tema padre original:\n' +
               '"' + padreARecomendar.padre.nombreCompleto + '"\n\n' +
               'Temas seleccionados: ' + padreARecomendar.temasSeleccionados.length + '\n\n' +
               'Se recomienda completar este tema antes de empezar otro tema padre original.\n' +
               'Esto mejora la retenci√≥n y el progreso sistem√°tico.\n\n' +
               '¬øQuieres continuar con el nuevo tema de todas formas?',
      temaPadreARecomendar: padreARecomendar.padre
    };
  }
  
  console.log('‚úÖ No hay conflictos de continuidad');
  return { debiaContinuar: false };
}

// Funci√≥n auxiliar para obtener todos los descendientes de un tema padre
function obtenerTodosLosDescendientes(temaPadre, arbolCompleto) {
  const descendientes = [];
  
  function recopilarDescendientes(nodo) {
    if (nodo.hijos && nodo.hijos.length > 0) {
      nodo.hijos.forEach(hijo => {
        descendientes.push(hijo);
        recopilarDescendientes(hijo); // Recursi√≥n para nietos, bisnietos, etc.
      });
    }
  }
  
  recopilarDescendientes(temaPadre);
  return descendientes;
}

// Funci√≥n para mostrar debug en ventana de alerta (para el usuario)
function mostrarDebugEstado() {
  const estado = debugEstadoSeleccion();
  
  let mensaje = 'üêõ DEBUG - Estado de Selecci√≥n:\n\n';
  mensaje += `üìã Temas en lista: ${estado.temasEnLista}\n`;
  mensaje += `‚úÖ Checkboxes marcados: ${estado.checkboxesMarcados}\n`;
  mensaje += `üîÑ Sincronizado: ${estado.sincronizado ? 'S√ç' : 'NO'}\n\n`;
  mensaje += `‚è±Ô∏è Tiempo usado: ${estado.tiempoUsado} min\n`;
  mensaje += `üíØ Tiempo real: ${estado.tiempoReal} min\n`;
  mensaje += `üì¶ Bloques activos: ${estado.bloquesActivos}\n\n`;
  
  if (!estado.sincronizado) {
    mensaje += '‚ö†Ô∏è PROBLEMA DETECTADO:\n';
    mensaje += 'La interfaz no est√° sincronizada con la lista.\n';
    mensaje += 'Usa el bot√≥n "Reparar Estado" para solucionarlo.';
  } else {
    mensaje += '‚úÖ Todo est√° funcionando correctamente.';
  }
  
  alert(mensaje);
}

// Funci√≥n para verificar autom√°ticamente el estado cada vez que se actualiza
function verificarEstadoAutomaticamente() {
  // Esta funci√≥n se ejecuta despu√©s de cada cambio
  setTimeout(() => {
    const estado = debugEstadoSeleccion();
    
    if (!estado.sincronizado) {
      console.warn('‚ö†Ô∏è PROBLEMA DE SINCRONIZACI√ìN DETECTADO AUTOM√ÅTICAMENTE');
      console.warn('   Se recomienda usar el bot√≥n de reparar estado');
      
      // Mostrar advertencia visual (opcional)
      const contenedorReglas = document.getElementById('informacionReglas');
      if (contenedorReglas) {
        let advertencia = contenedorReglas.querySelector('.advertencia-sincronizacion');
        if (!advertencia) {
          advertencia = document.createElement('div');
          advertencia.className = 'advertencia-sincronizacion';
          advertencia.style.cssText = 'background: #ffebee; color: #c62828; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 12px;';
          advertencia.innerHTML = '‚ö†Ô∏è <strong>Problema detectado:</strong> La interfaz no est√° sincronizada. Usa el bot√≥n "Reparar Estado".';
          contenedorReglas.appendChild(advertencia);
        }
      }
    } else {
      // Quitar advertencia si existe
      const advertencia = document.querySelector('.advertencia-sincronizacion');
      if (advertencia) {
        advertencia.remove();
      }
    }
  }, 500); // Esperar 500ms para que termine cualquier proceso de actualizaci√≥n
}

function actualizarEstadoVisualDelArbol() {
  // Funci√≥n para actualizar el estado visual del √°rbol seg√∫n los temas seleccionados
  console.log('üé® Actualizando estado visual del √°rbol');
  
  if (temasSeleccionados.length === 0) {
    return; // No hay nada que actualizar
  }
  
  // Obtener informaci√≥n de temas padre originales seleccionados
  const { detalles } = obtenerTemasPadreOriginalesSeleccionados();
  
  // Marcar visualmente los temas padre originales con progreso
  Object.values(detalles).forEach(detalle => {
    const temaPadreOriginal = detalle.padre;
    const temasSeleccionadosCount = detalle.temasSeleccionados.length;
    
    // Buscar el elemento visual del tema padre original
    const checkboxesEnPagina = document.querySelectorAll('input[type="checkbox"]');
    checkboxesEnPagina.forEach(checkbox => {
      const idTemaCheckbox = parseInt(checkbox.getAttribute('onchange')?.match(/\d+/)?.[0]);
      if (idTemaCheckbox === temaPadreOriginal.id) {
        const contenedor = checkbox.closest('div');
        if (contenedor) {
          // A√±adir badge de progreso
          let badge = contenedor.querySelector('.badge-progreso');
          if (!badge) {
            badge = document.createElement('span');
            badge.className = 'badge-progreso';
            badge.style.cssText = 'background: #4caf50; color: white; padding: 2px 8px; border-radius: 10px; font-size: 10px; margin-left: 10px;';
            checkbox.parentElement.appendChild(badge);
          }
          badge.textContent = `${temasSeleccionadosCount} seleccionados`;
        }
      }
    });
  });
}

// CORRECCI√ìN 34: En scriptsPlanificacion.html
// A√ëADIR esta nueva funci√≥n de debug (no reemplazar)

function debugEstadoSeleccion() {
  console.log('üêõ ===== DEBUG ESTADO SELECCI√ìN =====');
  
  // 1. Estado de la lista global
  console.log('üìã Lista global temasSeleccionados:', temasSeleccionados.length, 'temas');
  temasSeleccionados.forEach((tema, index) => {
    console.log(`   ${index + 1}. ID: ${tema.id}, Tiempo: ${tema.tiempo}min, Bloque: ${tema.bloque}, Tipo: ${tema.tipo}`);
  });
  
  // 2. Estado de checkboxes en la interfaz
  console.log('‚úÖ Estado de checkboxes en la interfaz:');
  const todosLosCheckboxes = document.querySelectorAll('input[type="checkbox"]');
  let checkboxesMarcados = 0;
  
  todosLosCheckboxes.forEach(checkbox => {
    if (checkbox.checked) {
      const onchangeAttr = checkbox.getAttribute('onchange');
      const match = onchangeAttr ? onchangeAttr.match(/toggleSeleccionTemaConValidacion\(this,\s*(\d+)/) : null;
      const idTemaCheckbox = match ? parseInt(match[1]) : 'Desconocido';
      
      console.log(`   ‚úÖ Checkbox marcado - ID: ${idTemaCheckbox}, Disabled: ${checkbox.disabled}`);
      checkboxesMarcados++;
    }
  });
  
  console.log(`üìä Total checkboxes marcados: ${checkboxesMarcados}`);
  
  // 3. Verificar sincronizaci√≥n
  const discrepancia = checkboxesMarcados !== temasSeleccionados.length;
  if (discrepancia) {
    console.warn('‚ö†Ô∏è DISCREPANCIA DETECTADA:');
    console.warn(`   Lista global: ${temasSeleccionados.length} temas`);
    console.warn(`   Checkboxes marcados: ${checkboxesMarcados}`);
    console.warn('   Esto puede causar problemas en la validaci√≥n de orden');
  } else {
    console.log('‚úÖ Sincronizaci√≥n correcta entre lista global y interfaz');
  }
  
  // 4. Estado de tiempo
  console.log('‚è±Ô∏è Estado de tiempo:');
  console.log(`   Tiempo total disponible: ${tiempoTotalDisponible} min`);
  console.log(`   Tiempo usado (calculado): ${tiempoUsado} min`);
  
  // Calcular tiempo real sumando la lista
  const tiempoRealCalculado = temasSeleccionados.reduce((total, tema) => total + tema.tiempo, 0);
  console.log(`   Tiempo real (sumando lista): ${tiempoRealCalculado} min`);
  
  if (tiempoUsado !== tiempoRealCalculado) {
    console.warn('‚ö†Ô∏è DISCREPANCIA EN TIEMPO:');
    console.warn(`   Variable tiempoUsado: ${tiempoUsado} min`);
    console.warn(`   Suma real de lista: ${tiempoRealCalculado} min`);
  }
  
  // 5. Estado de bloques
  console.log('üì¶ Bloques activos:', bloquesActivos);
  
  console.log('üêõ ===== FIN DEBUG =====');
  
  // Devolver informaci√≥n para uso externo
  return {
    temasEnLista: temasSeleccionados.length,
    checkboxesMarcados: checkboxesMarcados,
    sincronizado: !discrepancia,
    tiempoUsado: tiempoUsado,
    tiempoReal: tiempoRealCalculado,
    bloquesActivos: bloquesActivos.length
  };
}

// Funci√≥n para reparar discrepancias autom√°ticamente
function repararEstadoSeleccion() {
  console.log('üîß Reparando estado de selecci√≥n...');
  
  const estadoAntes = debugEstadoSeleccion();
  
  if (!estadoAntes.sincronizado) {
    console.log('üîß Sincronizando checkboxes con lista global...');
    
    // Desmarcar TODOS los checkboxes primero
    const todosLosCheckboxes = document.querySelectorAll('input[type="checkbox"]');
    todosLosCheckboxes.forEach(checkbox => {
      checkbox.checked = false;
      checkbox.disabled = false;
      
      // Limpiar estilos
      const contenedor = checkbox.closest('div[style*="padding"]');
      if (contenedor) {
        contenedor.style.opacity = '';
        contenedor.style.backgroundColor = '';
        
        // Remover badges
        const badges = contenedor.querySelectorAll('.badge-auto, span[style*="background: #2196f3"]');
        badges.forEach(badge => badge.remove());
      }
    });
    
    // Marcar solo los que est√°n en la lista global
    temasSeleccionados.forEach(tema => {
      const checkbox = encontrarCheckboxPorIdTema(tema.id);
      if (checkbox) {
        checkbox.checked = true;
        
        // Si es hijo autom√°tico, aplicar estilo especial
        if (tema.tipo === 'hijo_automatico') {
          checkbox.disabled = true;
          
          const contenedor = checkbox.closest('div[style*="padding"]');
          if (contenedor) {
            contenedor.style.opacity = '0.7';
            contenedor.style.backgroundColor = '#e3f2fd';
            
            const badge = document.createElement('span');
            badge.className = 'badge-auto';
            badge.textContent = 'AUTO';
            badge.style.cssText = 'background: #2196f3; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; margin-left: 10px;';
            checkbox.parentElement.appendChild(badge);
          }
        }
        
        console.log('‚úÖ Checkbox marcado para tema:', tema.id);
      } else {
        console.warn('‚ö†Ô∏è No se encontr√≥ checkbox para tema en lista:', tema.id);
      }
    });
    
    // Recalcular tiempo
    tiempoUsado = temasSeleccionados.reduce((total, tema) => total + tema.tiempo, 0);
    console.log('‚è±Ô∏è Tiempo recalculado:', tiempoUsado, 'min');
    
    // Actualizar interfaz
    actualizarResumenTiempo();
    
    console.log('‚úÖ Reparaci√≥n completada');
  } else {
    console.log('‚úÖ No se detectaron problemas - no se requiere reparaci√≥n');
  }
  
  const estadoDespues = debugEstadoSeleccion();
  return estadoDespues;
}

</script>
